---
phase: 02-closed-loop-editor
plan: 07
type: execute
wave: 5
depends_on: ["02-02", "02-05"]
files_modified:
  - apps/editor/src/stores/slices/playtest-slice.ts
  - apps/editor/src/stores/editor-store.ts
  - apps/editor/src/components/editor/playtest/play-controls.tsx
  - apps/editor/src/components/editor/playtest/play-mode-border.tsx
  - apps/editor/src/components/editor/shell/top-bar.tsx
  - apps/editor/src/components/editor/shell/editor-shell.tsx
  - packages/adapter-playcanvas/src/adapter.ts
  - apps/editor/src/hooks/use-keyboard-shortcuts.ts
autonomous: true
requirements:
  - EDIT-10

must_haves:
  truths:
    - "Pressing Play transitions to runtime mode with a colored border indicating play mode"
    - "During play mode, editor panels collapse but are peekable on hover"
    - "Pressing Pause freezes the runtime simulation"
    - "Pressing Stop restores the scene to its pre-play state (all runtime changes discarded)"
    - "Undo/redo stacks are cleared on Stop (play session changes are not undoable)"
    - "The viewport stays in the same location during play/stop transition (no page reload)"
  artifacts:
    - path: "apps/editor/src/stores/slices/playtest-slice.ts"
      provides: "Play/pause/stop state machine with ECSON snapshot"
      exports: ["PlaytestSlice"]
    - path: "apps/editor/src/components/editor/playtest/play-mode-border.tsx"
      provides: "Colored border overlay during play mode"
      contains: "isPlaying"
    - path: "apps/editor/src/components/editor/playtest/play-controls.tsx"
      provides: "Play/Pause/Stop button group"
      contains: "play.*pause.*stop"
  key_links:
    - from: "apps/editor/src/stores/slices/playtest-slice.ts"
      to: "editorStore scene-slice"
      via: "play snapshots ecsonDoc, stop restores it"
      pattern: "ecsonSnapshot.*deepClone"
    - from: "apps/editor/src/stores/slices/playtest-slice.ts"
      to: "packages/adapter-playcanvas"
      via: "play sets timeScale=1, stop restores and recompiles"
      pattern: "timeScale"
    - from: "apps/editor/src/components/editor/shell/editor-shell.tsx"
      to: "playtest-slice isPlaying"
      via: "panels collapse/expand based on play state"
      pattern: "isPlaying.*collapse"
---

<objective>
Implement the play-test mode that transitions the editor into runtime mode. Users press Play to see the scene run, Pause to freeze it, and Stop to restore the pre-play state. The viewport stays in place, panels collapse, and a colored border signals play mode.

Purpose: Play-test is the final piece of the closed-loop editor. It proves the entire pipeline works: create content -> see it render -> play it -> stop -> continue editing. Without play-test, users can't validate what they've built.
Output: Working play/pause/stop with scene snapshot/restore, visual play mode indicator, panel collapse behavior.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-closed-loop-editor/02-RESEARCH.md
@.planning/phases/02-closed-loop-editor/02-CONTEXT.md
@.planning/phases/02-closed-loop-editor/02-02-SUMMARY.md
@.planning/phases/02-closed-loop-editor/02-05-SUMMARY.md
@packages/adapter-playcanvas/src/adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Playtest state machine with snapshot/restore</name>
  <files>
    apps/editor/src/stores/slices/playtest-slice.ts
    apps/editor/src/stores/editor-store.ts
    packages/adapter-playcanvas/src/adapter.ts
  </files>
  <action>
    **Playtest Slice** (`stores/slices/playtest-slice.ts`):
    State:
    ```typescript
    interface PlaytestSlice {
      isPlaying: boolean;
      isPaused: boolean;
      ecsonSnapshot: SceneDocument | null;

      play: () => void;
      pause: () => void;
      resume: () => void;
      stop: () => void;
    }
    ```

    **play():**
    1. Get current `ecsonDoc` from scene slice
    2. Deep-clone it as `ecsonSnapshot` (use `JSON.parse(JSON.stringify(doc))` -- same JSON clone pattern established in Phase 1 per decision [01-03])
    3. Set `isPlaying: true`, `isPaused: false`
    4. Signal the PlayCanvas adapter to enter runtime mode:
       - Set `app.timeScale = 1` (resume time progression)
       - Enable physics stepping (if physics components exist -- Phase 7 will add actual physics, but the adapter should support a `setPlayMode(true)` call)
       - Disable editor-only features: hide grid, disable gizmos, disable selection picking
       - Switch to the scene's own camera if one exists (fall back to editor camera if not)

    **pause():**
    1. Set `isPaused: true`
    2. Signal adapter: set `app.timeScale = 0` (freeze simulation)
    3. Editor features remain disabled

    **resume():**
    1. Set `isPaused: false`
    2. Signal adapter: set `app.timeScale = 1`

    **stop():**
    1. Get `ecsonSnapshot`
    2. Restore: set `ecsonDoc = ecsonSnapshot` in scene slice
    3. Clear: `ecsonSnapshot = null`, `isPlaying = false`, `isPaused = false`
    4. Clear undo/redo stacks (play session ops are not undoable, per research pattern)
    5. Recompile IR from restored doc
    6. Signal adapter:
       - `rebuildScene(compiledIR)` -- rebuild from the restored pre-play ECSON
       - Re-enable editor features: show grid, enable gizmos, enable selection
       - Restore editor camera
       - Set `app.timeScale = 0` (back to editor mode -- time doesn't run)

    **"Keep changes" decision:** Per user decision context and research open question #5, defer "keep runtime changes" to future enhancement. Ship discard-all on Stop. No UI prompt needed.

    **Update PlayCanvas Adapter** (`adapter.ts`):
    - Add `setPlayMode(playing: boolean)`:
      - `playing = true`: Hide grid entity, detach all gizmos, disable selection manager, set timeScale = 1
      - `playing = false`: Show grid entity, re-enable gizmos/selection if entities are selected, set timeScale = 0
    - Add `setTimeScale(scale: number)`: Wrapper for `app.timeScale = scale`
    - Editor camera vs scene camera: Track which camera is active. On play, switch to first scene camera if one exists. On stop, restore editor camera.

    **Compose into editor-store.ts:** Add playtest-slice to the combined store.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm lint` passes
    - Play/pause/stop state transitions are correct
    - ecsonSnapshot is deep-cloned on play, restored on stop
    - Undo/redo stacks are cleared on stop
    - Adapter setPlayMode toggles grid/gizmos/selection/timeScale
  </verify>
  <done>
    Playtest state machine handles play (snapshot + enter runtime), pause (freeze), resume, and stop (restore + rebuild). ECSON is deep-cloned before play and restored on stop. Adapter supports play mode toggling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Play controls UI, visual indicator, and panel collapse</name>
  <files>
    apps/editor/src/components/editor/playtest/play-controls.tsx
    apps/editor/src/components/editor/playtest/play-mode-border.tsx
    apps/editor/src/components/editor/shell/top-bar.tsx
    apps/editor/src/components/editor/shell/editor-shell.tsx
    apps/editor/src/hooks/use-keyboard-shortcuts.ts
  </files>
  <action>
    **Play Controls** (`playtest/play-controls.tsx`):
    - Button group component with three buttons: Play, Pause, Stop
    - Use Lucide icons: Play (PlayCircle), Pause (PauseCircle), Stop (StopCircle or Square)
    - State-dependent rendering:
      - Not playing: Play button enabled (green tint), Pause/Stop disabled
      - Playing: Pause and Stop enabled, Play swaps to show "Playing..." state
      - Paused: Resume (play icon) and Stop enabled, Pause disabled
    - Connected to store: `play()`, `pause()`, `resume()`, `stop()`
    - Per user decision: centered in the top bar, always visible regardless of mode.

    **Update TopBar:** Replace the placeholder play controls with the real PlayControls component. Ensure it's centered using flex layout. The save status and project name remain on left/right.

    **Play Mode Border** (`playtest/play-mode-border.tsx`):
    - Per user decision: in-place transition with colored border/tint signaling play mode (like Unity's blue tint).
    - Renders a semi-transparent colored border around the viewport area when `isPlaying` is true.
    - Border: 3px solid with a pulsing glow effect. Color: a distinct play-mode color (e.g., cyan/teal or blue).
    - Paused state: border changes to a different color (e.g., orange/amber) or becomes dashed/static.
    - Mount as an absolutely positioned overlay on the viewport container. `pointer-events: none` so it doesn't block interaction.

    **Panel Collapse** (update `editor-shell.tsx`):
    - Per user decision: panels collapse when entering play mode but are "peekable" -- user can hover or toggle panels back temporarily.
    - On `isPlaying === true`:
      1. Collapse left and right panels to 0 width (use react-resizable-panels' `collapse()` method or set size to 0)
      2. Activity bar stays visible but dimmed
    - Peekable behavior:
      - Hovering on the edge of where a collapsed panel was shows a thin activation strip
      - Clicking the activation strip or hovering for 300ms temporarily expands the panel
      - Moving the mouse away from the panel area collapses it again after a short delay
      - Alternative simpler approach: clicking activity bar icons temporarily shows the panel (floating overlay), clicking away hides it
    - On `isPlaying === false` (stop): restore panel sizes to their pre-play state (save panel sizes before collapse, restore on stop).

    **Keyboard Shortcuts:**
    - Add `Ctrl+P` or `F5` -> toggle play/stop:
      - If not playing: `play()`
      - If playing: `stop()`
    - Add `Space` (while playing) -> toggle pause/resume
    - Guard: Space shortcut only active during play mode to avoid conflicts with text input.

    **TopBar play state indication:** In addition to the viewport border, the top bar should subtly indicate play state:
    - Playing: top bar background shifts to a slightly tinted color (subtle blue/cyan tint)
    - Paused: top bar shows "PAUSED" label or the pause icon
    - Normal: default dark background
  </action>
  <verify>
    - `pnpm typecheck --filter @riff3d/editor` passes
    - `pnpm lint --filter @riff3d/editor` passes
    - Play button starts play mode, border appears, panels collapse
    - Pause freezes simulation, border changes
    - Stop restores scene, border disappears, panels expand
    - Panels are peekable during play mode
    - Keyboard shortcuts (Ctrl+P, Space) work correctly
    - Top bar shows play state
  </verify>
  <done>
    Play/Pause/Stop controls in top bar with correct state transitions. Colored border around viewport during play mode. Panels collapse on play and are peekable. Stop restores pre-play scene state. Keyboard shortcuts for play control.
  </done>
</task>

</tasks>

<verification>
- Full play cycle: Play -> scene runs -> Pause -> frozen -> Resume -> runs -> Stop -> scene restored
- Colored border visible during play mode (different color for paused)
- Panels collapse on play, peekable on hover/click
- Panels restore on stop to their previous sizes
- Scene state matches pre-play state after Stop (undo/redo cleared)
- No page reload during play/stop transition
- Keyboard shortcuts (Ctrl+P, Space) work
</verification>

<success_criteria>
- Play-test from editor works with in-place transition, no page reload (EDIT-10)
- Colored border signals play mode
- Panels collapse but are peekable during play
- Stop restores exact pre-play scene state (discard runtime changes)
- Play/Pause/Stop controls centered in top bar per user decision
</success_criteria>

<output>
After completion, create `.planning/phases/02-closed-loop-editor/02-07-SUMMARY.md`
</output>
