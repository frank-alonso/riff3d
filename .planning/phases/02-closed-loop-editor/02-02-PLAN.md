---
phase: 02-closed-loop-editor
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/adapter-playcanvas/package.json
  - packages/adapter-playcanvas/tsconfig.json
  - packages/adapter-playcanvas/vitest.config.ts
  - packages/adapter-playcanvas/src/index.ts
  - packages/adapter-playcanvas/src/adapter.ts
  - packages/adapter-playcanvas/src/scene-builder.ts
  - packages/adapter-playcanvas/src/component-mappers/index.ts
  - packages/adapter-playcanvas/src/component-mappers/mesh-renderer.ts
  - packages/adapter-playcanvas/src/component-mappers/light.ts
  - packages/adapter-playcanvas/src/component-mappers/camera.ts
  - packages/adapter-playcanvas/src/component-mappers/material.ts
  - packages/adapter-playcanvas/src/environment.ts
  - packages/adapter-playcanvas/src/camera-controller.ts
  - packages/adapter-playcanvas/src/types.ts
  - apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  - apps/editor/src/components/editor/viewport/viewport-provider.tsx
  - apps/editor/src/stores/editor-store.ts
  - apps/editor/src/stores/slices/scene-slice.ts
  - apps/editor/src/stores/slices/viewport-slice.ts
  - apps/editor/src/components/editor/shell/editor-shell.tsx
  - packages/canonical-ir/src/compiler.ts
  - pnpm-workspace.yaml
  - turbo.json
autonomous: true
requirements:
  - EDIT-01
  - ADPT-01
  - RNDR-01
  - RNDR-02
  - RNDR-03

must_haves:
  truths:
    - "3D viewport renders a PlayCanvas scene inside the editor shell center area"
    - "Default blank scene shows a ground plane, directional light, sky/environment, and placeholder objects (cube, sphere)"
    - "User can orbit, pan, and zoom the camera (Alt+click orbit, Alt+middle pan, scroll zoom)"
    - "User can toggle to fly camera mode (right-click+drag to look, WASD to move)"
    - "PBR materials render correctly (color, metalness, roughness, emissive)"
    - "Directional, point, and spot lights illuminate the scene"
    - "Scene is compiled from ECSON through Canonical IR to PlayCanvas adapter"
  artifacts:
    - path: "packages/adapter-playcanvas/src/adapter.ts"
      provides: "PlayCanvasAdapter implementing EngineAdapter interface"
      exports: ["PlayCanvasAdapter"]
    - path: "packages/adapter-playcanvas/src/scene-builder.ts"
      provides: "IR-to-PlayCanvas entity hierarchy builder"
      exports: ["buildScene"]
    - path: "apps/editor/src/components/editor/viewport/viewport-canvas.tsx"
      provides: "Canvas element with PlayCanvas initialization"
      contains: "useRef.*canvas"
    - path: "apps/editor/src/stores/slices/scene-slice.ts"
      provides: "ECSON doc state and dispatchOp action"
      contains: "dispatchOp"
  key_links:
    - from: "apps/editor/src/stores/slices/scene-slice.ts"
      to: "@riff3d/patchops applyOp"
      via: "dispatchOp calls applyOp(ecsonDoc, op)"
      pattern: "applyOp"
    - from: "packages/adapter-playcanvas/src/adapter.ts"
      to: "@riff3d/canonical-ir compile"
      via: "loadScene compiles ECSON to IR then builds PC scene"
      pattern: "compile"
    - from: "apps/editor/src/components/editor/viewport/viewport-canvas.tsx"
      to: "packages/adapter-playcanvas"
      via: "useEffect initializes adapter and subscribes to store"
      pattern: "PlayCanvasAdapter"
    - from: "editorStore"
      to: "PlayCanvasAdapter"
      via: "store.subscribe for ecsonDoc changes triggers adapter rebuild"
      pattern: "subscribe.*ecsonDoc"
---

<objective>
Create the PlayCanvas adapter package and integrate it into the editor viewport. The adapter reads Canonical IR (compiled from ECSON) and builds a PlayCanvas scene with PBR materials, lighting, and camera controls. This is the first time the full pipeline (ECSON -> Canonical IR -> PlayCanvas) runs in the browser.

Purpose: The viewport is the core of the editor. Without it rendering a 3D scene, nothing else (gizmos, inspector, play-test) can function. This plan proves the pipeline works end-to-end.
Output: Working PlayCanvas viewport in the editor, adapter package, camera controls, default starter scene.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-closed-loop-editor/02-RESEARCH.md
@.planning/phases/02-closed-loop-editor/02-CONTEXT.md
@.planning/phases/02-closed-loop-editor/02-01-SUMMARY.md
@packages/canonical-ir/src/index.ts
@packages/canonical-ir/src/compiler.ts
@packages/ecson/src/index.ts
@packages/ecson/src/helpers.ts
@packages/ecson/src/schemas/scene-document.ts
</context>

<executor_notes>
**Context budget warning:** This plan touches ~23 files across 2 tasks. Task 1 creates an entire new package (~16 files) and Task 2 integrates it into the editor (~6 files). To manage context:
- Task 1: Build the adapter package in isolation. Focus on: adapter.ts > scene-builder.ts > component mappers > camera-controller.ts > environment.ts. The component mappers are repetitive (same pattern, different properties), so batch them.
- Task 2: Read the adapter's public API (index.ts, types.ts) and the store slices. Don't re-read all adapter internals.
- If context runs tight, prioritize scene-builder and mesh-renderer mapper (the minimum to see geometry). Light/camera/material mappers can be simpler initially.
</executor_notes>

<tasks>

<task type="auto">
  <name>Task 1: PlayCanvas adapter package and scene builder</name>
  <files>
    packages/adapter-playcanvas/package.json
    packages/adapter-playcanvas/tsconfig.json
    packages/adapter-playcanvas/vitest.config.ts
    packages/adapter-playcanvas/src/index.ts
    packages/adapter-playcanvas/src/types.ts
    packages/adapter-playcanvas/src/adapter.ts
    packages/adapter-playcanvas/src/scene-builder.ts
    packages/adapter-playcanvas/src/component-mappers/index.ts
    packages/adapter-playcanvas/src/component-mappers/mesh-renderer.ts
    packages/adapter-playcanvas/src/component-mappers/light.ts
    packages/adapter-playcanvas/src/component-mappers/camera.ts
    packages/adapter-playcanvas/src/component-mappers/material.ts
    packages/adapter-playcanvas/src/environment.ts
    packages/adapter-playcanvas/src/camera-controller.ts
    pnpm-workspace.yaml
    turbo.json
  </files>
  <action>
    **Create new package `packages/adapter-playcanvas`:**

    `package.json`:
    ```json
    {
      "name": "@riff3d/adapter-playcanvas",
      "version": "0.0.1",
      "private": true,
      "type": "module",
      "exports": { ".": "./src/index.ts" },
      "scripts": {
        "test": "vitest run",
        "typecheck": "tsc --noEmit",
        "lint": "eslint ."
      },
      "dependencies": {
        "playcanvas": "~2.16.0",
        "@riff3d/canonical-ir": "workspace:*"
      },
      "devDependencies": {
        "typescript": "^5",
        "vitest": "catalog:"
      }
    }
    ```

    **CRITICAL: Do NOT add `@riff3d/ecson` as a dependency.** Per architecture rule #3, adapters read Canonical IR only. If any shared type (like entity ID shape) is needed, it must come from `@riff3d/canonical-ir`.

    `tsconfig.json`: Extend `../../tsconfig.base.json`, include `src`, `__tests__`.

    **Types** (`src/types.ts`):
    ```typescript
    import type { CanonicalScene } from '@riff3d/canonical-ir';

    export interface EngineAdapter {
      initialize(canvas: HTMLCanvasElement): Promise<void>;
      loadScene(scene: CanonicalScene): void;
      rebuildScene(scene: CanonicalScene): void;
      getEntityMap(): Map<string, unknown>;  // entityId -> engine entity
      resize(): void;
      dispose(): void;
    }

    export interface CameraMode {
      type: 'fly' | 'orbit';
    }
    ```

    **Adapter** (`src/adapter.ts`):
    Main class `PlayCanvasAdapter` implements `EngineAdapter`.
    - `initialize(canvas)`: Create `pc.Application` with mouse + keyboard input. Set fill mode to FILLMODE_NONE (container-managed), resolution AUTO. Call `app.start()`. Set up resize handler. Create editor camera entity (not part of the scene -- separate from scene cameras). Set up camera controllers (see camera-controller.ts).
    - `loadScene(scene)`: Call `buildScene(app, scene)` to create PlayCanvas entities. Store entity map (`Map<string, pc.Entity>`). Apply environment settings.
    - `rebuildScene(scene)`: Destroy existing scene entities, rebuild from new IR.
    - `getEntityMap()`: Return the entity-to-PC-entity map.
    - `resize()`: Call `app.resizeCanvas()`.
    - `dispose()`: Destroy the application, clean up event listeners.
    - Internal: Maintain `entityMap: Map<string, pc.Entity>` mapping ECSON entity IDs to PlayCanvas Entity objects. NEVER put these in Zustand store.

    **CRITICAL:** PlayCanvas Canvas Lifecycle -- use a ref to track initialization status. Call `app.destroy()` in cleanup. Handle React Strict Mode double-effect by checking if already initialized.

    **Scene Builder** (`src/scene-builder.ts`):
    - `buildScene(app: pc.Application, scene: CanonicalScene)`: Iterate `scene.nodes` array (already BFS-sorted by the IR compiler, parents before children). For each node:
      1. Create `new pc.Entity(node.name)` and store in entityMap keyed by `node.id`
      2. Set transform: `entity.setLocalPosition(...)`, `entity.setLocalEulerAngles(...)` (convert quaternion to euler for PlayCanvas), `entity.setLocalScale(...)`
      3. If node has `parentId`, reparent under the parent entity (looked up from entityMap)
      4. For each component in `node.components`, call the appropriate component mapper
      5. Add root-level entities to `app.root`
    - Return: `{ entityMap, rootEntities }`

    **Component Mappers:**
    - `mesh-renderer.ts`: Map `MeshRenderer` IR component to PlayCanvas `render` component. For primitive shapes (box, sphere, plane, cylinder, cone, capsule), use `pc.createPrimitive()` or add `render` component with type. Support mesh asset references for GLB-imported meshes.
    - `light.ts`: Map `Light` IR component to PlayCanvas `light` component. Map types: `directional` -> `directional`, `point` -> `omni`, `spot` -> `spot`. Map color (hex string to `pc.Color`), intensity, range, shadows, shadow properties.
    - `camera.ts`: Map `Camera` IR component to PlayCanvas `camera` component. Map projection (perspective/orthographic), fov, near/far clip, ortho height. Scene cameras are rendered but NOT used for editor navigation (editor has its own camera).
    - `material.ts`: Map `Material` IR component to PlayCanvas `StandardMaterial`. Map: `baseColor` hex -> `diffuse` Color, `metallic` -> `metalness`, `roughness` -> `gloss` (invert: gloss = 1 - roughness), `emissive` hex -> `emissive` Color + `emissiveIntensity`, `opacity`, `doubleSided` -> `cull` and `twoSidedLighting`. Call `mat.update()` after setting properties.

    **Environment** (`src/environment.ts`):
    - `applyEnvironment(app, env: CanonicalEnvironment)`: Set `app.scene.ambientLight` from environment ambient color. Set fog properties. Set skybox color (solid color skybox for Phase 2 -- image skybox deferred to 02-06). Set exposure.

    **Camera Controller** (`src/camera-controller.ts`):
    - Set up both OrbitController and FlyController from PlayCanvas extras. Use `KeyboardMouseSource` for input.
    - Per user decision: default mode is game-style (fly). Toggle via function call from store subscription.
    - `OrbitController`: Alt+click to orbit, Alt+middle to pan, scroll to zoom. Damping 0.98.
    - `FlyController`: Right-click+drag to look, WASD to move. Damping 0.98.
    - `switchCameraMode(mode)`: Detach current controller, attach new one with same pose.
    - In app.on('update', dt) loop: get input frame, update active controller, apply pose to editor camera entity.

    **Carry-forward CF-06:** Add JSDoc comments to the scene-builder.ts and adapter.ts documenting IR conventions: coordinate system (right-handed, Y-up), physics units (meters), roughness (0=smooth, 1=rough), 1:N entity-to-node mapping. This addresses CF-06 by documenting conventions in source code where they matter.

    **Update workspace files:**
    - `pnpm-workspace.yaml`: No changes needed (packages/* already included)
    - `turbo.json`: Ensure adapter-playcanvas tasks are included in build/test/typecheck/lint pipelines (should auto-include as workspace package)

    Run `pnpm install` to link the new package.
  </action>
  <verify>
    - `pnpm typecheck --filter @riff3d/adapter-playcanvas` passes
    - `pnpm lint --filter @riff3d/adapter-playcanvas` passes
    - Package exports are correct: `PlayCanvasAdapter`, `EngineAdapter`, `buildScene`
    - Component mappers exist for: mesh-renderer, light, camera, material
    - CF-06 conventions documented in JSDoc comments
  </verify>
  <done>
    PlayCanvas adapter package created with scene builder, component mappers (mesh, light, camera, material), environment settings, and camera controllers (orbit + fly). IR conventions documented in source code.
  </done>
</task>

<task type="auto">
  <name>Task 2: Viewport integration, scene slice, and default starter scene</name>
  <files>
    apps/editor/src/components/editor/viewport/viewport-canvas.tsx
    apps/editor/src/components/editor/viewport/viewport-provider.tsx
    apps/editor/src/stores/editor-store.ts
    apps/editor/src/stores/slices/scene-slice.ts
    apps/editor/src/stores/slices/viewport-slice.ts
    apps/editor/src/components/editor/shell/editor-shell.tsx
  </files>
  <action>
    **Scene slice** (`stores/slices/scene-slice.ts`):
    - State: `ecsonDoc: SceneDocument | null`, `canonicalScene: CanonicalScene | null`, `selectedEntityIds: string[]`
    - Actions:
      - `loadProject(doc: SceneDocument)`: Set ecsonDoc, compile to IR via `compile(doc)` from `@riff3d/canonical-ir`, set canonicalScene.
      - `dispatchOp(op: PatchOp)`: Call `applyOp(ecsonDoc, op)` from `@riff3d/patchops`, receive inverse op, recompile IR, return inverse. (Undo/redo stacks added in 02-05.)
      - `setSelection(ids: string[])`: Set selectedEntityIds.
    - Import `compile` from `@riff3d/canonical-ir` and `applyOp` from `@riff3d/patchops`.

    **Viewport slice** (`stores/slices/viewport-slice.ts`):
    - State: `gizmoMode: 'translate' | 'rotate' | 'scale'`, `cameraMode: 'fly' | 'orbit'`, `snapEnabled: boolean`, `gridSize: number`, `rotationSnap: number`
    - Actions: `setGizmoMode()`, `setCameraMode()`, `toggleSnap()`, `setGridSize()`.
    - Defaults: `gizmoMode: 'translate'`, `cameraMode: 'fly'` (per user decision), `snapEnabled: false`, `gridSize: 1`, `rotationSnap: 15`.

    **Update editor-store.ts:** Compose scene-slice and viewport-slice into the store using the Zustand slices pattern. The store should export all state and actions from both slices plus the existing UI slice.

    **Viewport Canvas** (`viewport/viewport-canvas.tsx`):
    - Client component (`'use client'`). Renders a `<canvas>` element that fills its container.
    - On mount (`useEffect` with cleanup):
      1. Create `PlayCanvasAdapter` instance
      2. Call `adapter.initialize(canvasRef.current)`
      3. Get `ecsonDoc` from `editorStore.getState()` -- if it exists, compile and load scene
      4. Subscribe to store changes:
         - `ecsonDoc` changes -> `adapter.rebuildScene(compile(doc))`
         - `cameraMode` changes -> switch camera controller
      5. On cleanup: `adapter.dispose()`
    - Use a ref (`isInitialized`) to handle React Strict Mode double-effect.
    - Handle container resize via `ResizeObserver` -> `adapter.resize()`.
    - **CRITICAL:** Use `dynamic(() => import('./viewport-canvas'), { ssr: false })` in the parent to prevent SSR. Guard `window`/`document` access.

    **Viewport Provider** (`viewport/viewport-provider.tsx`):
    - Context provider that holds the adapter instance ref. Allows child components (gizmo manager, selection manager -- added in 02-03) to access the PlayCanvas adapter.
    - Exports `useViewportAdapter()` hook.

    **Default starter scene:**
    When a new project is created (in the NewProjectModal from 02-01), generate a default ECSON document using `createEmptyDocument()` from `@riff3d/ecson`, then apply starter PatchOps to add:
    - Ground plane entity (MeshRenderer with plane shape, scaled 10x10, at y=0)
    - Directional light entity (pointing down at 45 degrees, warm white, shadows enabled)
    - Cube entity (position [0, 0.5, 0])
    - Sphere entity (position [2, 0.5, 0])
    - Set environment: ambient light, sky color (dark blue gradient or solid neutral)

    Create a helper `lib/default-scene.ts` that builds and returns the ECSON with these entities. Use this when creating new projects in the dashboard.

    **Update EditorShell:** Replace the viewport placeholder div with the ViewportProvider + ViewportCanvas component (loaded via dynamic import with `ssr: false`). The editor page should:
    1. Load project data from Supabase (server component in layout)
    2. Pass ECSON doc to client-side editor shell
    3. EditorShell calls `editorStore.getState().loadProject(doc)` on mount
    4. ViewportCanvas picks up the doc from store and renders it
  </action>
  <verify>
    - `pnpm typecheck` passes across all packages (including new adapter-playcanvas)
    - `pnpm lint` passes
    - Visiting /editor/[projectId] renders a 3D scene in the viewport area
    - Scene contains visible geometry (ground plane, cube, sphere) with lighting
    - Camera orbit works (Alt+click), fly mode works (right-click+WASD)
    - Resizing the browser window resizes the viewport
  </verify>
  <done>
    PlayCanvas viewport renders inside the editor shell. Default starter scene shows ground plane, directional light, cube, and sphere with PBR materials. Camera controls work in both fly (default) and orbit modes. ECSON doc loads from Supabase, compiles through Canonical IR, and renders via PlayCanvas adapter. The full pipeline (ECSON -> IR -> PlayCanvas) works end-to-end.
  </done>
</task>

</tasks>

<verification>
- PlayCanvas adapter package compiles and exports correctly
- Component mappers handle: mesh-renderer, light, camera, material
- Viewport renders inside the editor shell center area
- Default scene has visible geometry and lighting
- Camera orbit (Alt+click) and fly (right-click+WASD) both work
- Camera mode toggle works via store state change
- ECSON -> Canonical IR -> PlayCanvas pipeline verified end-to-end
- CF-06 IR conventions documented in adapter source code
</verification>

<success_criteria>
- A 3D scene renders in the viewport with PBR materials and lighting
- Camera controls allow orbit/pan/zoom and WASD fly-camera (EDIT-01)
- The scene is powered by the PlayCanvas adapter reading Canonical IR (ADPT-01)
- PBR materials display correctly: color, metalness, roughness, emissive (RNDR-01)
- Directional, point, and spot lights work (RNDR-02)
- Camera entities in the scene are recognized (RNDR-03)
- Resizing the viewport container resizes the canvas
</success_criteria>

<output>
After completion, create `.planning/phases/02-closed-loop-editor/02-02-SUMMARY.md`
</output>
