---
phase: 02-closed-loop-editor
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - packages/adapter-playcanvas/src/gizmo-manager.ts
  - packages/adapter-playcanvas/src/selection-manager.ts
  - packages/adapter-playcanvas/src/grid.ts
  - apps/editor/src/components/editor/viewport/floating-toolbar.tsx
  - apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  - apps/editor/src/stores/editor-store.ts
  - apps/editor/src/stores/slices/viewport-slice.ts
  - apps/editor/src/hooks/use-keyboard-shortcuts.ts
autonomous: true
requirements:
  - EDIT-02
  - EDIT-07

must_haves:
  truths:
    - "User can click an entity in the viewport to select it (highlight/outline visible)"
    - "User can Shift+click to add/remove from selection"
    - "User can drag a rectangle to box-select multiple entities"
    - "Selected entity shows translate gizmo with RGB axes (red=X, green=Y, blue=Z)"
    - "User can switch between translate (W), rotate (E), and scale (R) gizmos"
    - "Dragging a gizmo axis moves/rotates/scales the entity and creates a PatchOp on drag end"
    - "Snap-to-grid works when enabled (configurable grid size and rotation snap)"
    - "A visible grid plane renders on the ground"
  artifacts:
    - path: "packages/adapter-playcanvas/src/gizmo-manager.ts"
      provides: "Gizmo lifecycle management (create, attach, switch mode)"
      exports: ["GizmoManager"]
    - path: "packages/adapter-playcanvas/src/selection-manager.ts"
      provides: "Entity picking via raycasting and box selection"
      exports: ["SelectionManager"]
    - path: "packages/adapter-playcanvas/src/grid.ts"
      provides: "Grid plane mesh entity"
      exports: ["createGrid"]
    - path: "apps/editor/src/components/editor/viewport/floating-toolbar.tsx"
      provides: "Figma-style floating toolbar with gizmo mode buttons"
      contains: "gizmoMode"
  key_links:
    - from: "packages/adapter-playcanvas/src/gizmo-manager.ts"
      to: "editorStore"
      via: "store.subscribe for gizmoMode and selection changes"
      pattern: "subscribe.*gizmoMode"
    - from: "packages/adapter-playcanvas/src/gizmo-manager.ts"
      to: "editorStore dispatchOp"
      via: "transform:end creates SetProperty PatchOp"
      pattern: "dispatchOp.*SetProperty"
    - from: "packages/adapter-playcanvas/src/selection-manager.ts"
      to: "editorStore setSelection"
      via: "click/box-select updates store selection"
      pattern: "setSelection"
---

<objective>
Add transform gizmos (translate, rotate, scale), entity selection (click, shift-click, box select), grid/snap system, and a floating viewport toolbar. Users can now interact with the 3D scene by selecting entities and transforming them, with each transform producing a PatchOp.

Purpose: Without selection and gizmos, the editor is view-only. This plan makes the viewport interactive, proving that user actions in the 3D view flow through PatchOps.
Output: Working gizmos, selection system, grid, snap, floating toolbar.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-closed-loop-editor/02-RESEARCH.md
@.planning/phases/02-closed-loop-editor/02-CONTEXT.md
@.planning/phases/02-closed-loop-editor/02-02-SUMMARY.md
@packages/adapter-playcanvas/src/adapter.ts
@packages/adapter-playcanvas/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gizmo manager, selection manager, and grid</name>
  <files>
    packages/adapter-playcanvas/src/gizmo-manager.ts
    packages/adapter-playcanvas/src/selection-manager.ts
    packages/adapter-playcanvas/src/grid.ts
    apps/editor/src/stores/editor-store.ts
    apps/editor/src/stores/slices/viewport-slice.ts
  </files>
  <action>
    **Gizmo Manager** (`packages/adapter-playcanvas/src/gizmo-manager.ts`):
    - Class `GizmoManager` that manages PlayCanvas TranslateGizmo, RotateGizmo, ScaleGizmo lifecycle.
    - Constructor: Takes `app: pc.Application`, `cameraEntity: pc.Entity`, and the `editorStore` reference.
    - `initialize()`:
      1. Create gizmo layer via `Gizmo.createLayer(app)`
      2. Create all three gizmos: `new TranslateGizmo(camera, gizmoLayer)`, `new RotateGizmo(...)`, `new ScaleGizmo(...)`
      3. Per user decision: standard RGB axes (red=X, green=Y, blue=Z) -- this is PlayCanvas default
      4. Subscribe to `editorStore` for `gizmoMode` changes -> switch active gizmo
      5. Subscribe to `editorStore` for `selectedEntityIds` changes -> attach/detach gizmos from PlayCanvas entities (lookup via adapter entityMap)
      6. Subscribe to `editorStore` for `snapEnabled` and `gridSize` -> update gizmo `snap` and `snapIncrement` properties
    - **Gizmo event handling (CRITICAL for PatchOps flow):**
      - `transform:start`: Capture the current transform values (position/rotation/scale) of all selected entities. Store as `previousValues`.
      - During drag: PlayCanvas updates entity transforms directly (visual feedback). Do NOT create PatchOps during drag.
      - `transform:end`: Read final transform values. Create a single `SetProperty` PatchOp (or BatchOp for multi-select) with the final value and `previousValue` captured at start. Dispatch via `editorStore.getState().dispatchOp(op)`. This ensures one undoable op per drag gesture, not one per frame.
    - `switchGizmo(mode)`: Detach current gizmo, set new active gizmo, re-attach to selected nodes if any.
    - `updateSnap(enabled, gridSize, rotationSnap)`: Set `gizmo.snap = enabled`, `gizmo.snapIncrement = gridSize` for translate/scale, and rotation snap for rotate gizmo.
    - `dispose()`: Destroy all three gizmos.

    **Selection Manager** (`packages/adapter-playcanvas/src/selection-manager.ts`):
    - Class `SelectionManager` that handles entity picking in the viewport.
    - Constructor: Takes `app`, `cameraEntity`, `editorStore`, `entityMap`.
    - **Click selection:**
      - On canvas `mousedown` + `mouseup` (within short time/distance threshold to distinguish from drag):
        1. Use frustum-based screen-space projection: project all entity bounding boxes to screen space, check if click point intersects any projected bounds. Sort by distance, pick closest.
        2. If entity found:
           - No modifier: `setSelection([entityId])`
           - Shift held: Toggle entity in selection (add if not present, remove if present)
        3. If no entity found and no modifier: `setSelection([])` (deselect)
      - Alternative approach if frustum is insufficient: Use PlayCanvas `Picker` for framebuffer picking as fallback.
    - **Box/marquee selection:**
      - On canvas `mousedown` without Alt (Alt is for camera): Start tracking rectangle.
      - On `mousemove`: Draw selection rectangle overlay (CSS-based overlay div, not Canvas-drawn -- simpler and avoids WebGL state conflicts).
      - On `mouseup`: Project all entity bounding boxes to screen space, check containment within rectangle.
        - No modifier: select all contained entities
        - Shift: add contained entities to current selection
      - The selection rectangle is a semi-transparent blue div with dashed border, absolutely positioned over the canvas.
    - **Selection visual feedback:** When entities are selected, apply a highlight. Options:
      - Use PlayCanvas entity selection highlight (outline or tint). Simplest: set a selection layer or material override on selected entities.
      - Or use a simple approach: scale a wireframe bounding box around selected entities.
    - `dispose()`: Remove event listeners.

    **Grid** (`packages/adapter-playcanvas/src/grid.ts`):
    - `createGrid(app, gridSize)`: Create a grid plane entity at Y=0 using programmatically generated line mesh.
    - Grid extends to reasonable size (e.g., 100x100 units).
    - Grid lines are subtle (neutral-600/700 color, thin lines).
    - Major grid lines every 10 units slightly brighter.
    - Grid is not selectable (exclude from selection picking).
    - `updateGrid(entity, gridSize)`: Rebuild grid mesh when grid size changes.

    **Update viewport-slice:** Add `rotationSnap: number` to viewport slice state (default 15 degrees). Update `setRotationSnap()` action.
  </action>
  <verify>
    - `pnpm typecheck` passes across all packages
    - `pnpm lint` passes
    - GizmoManager creates and switches between translate/rotate/scale gizmos
    - SelectionManager handles click, shift-click, and box select
    - Grid renders at Y=0 with visible lines
    - Gizmo events produce PatchOps only on transform:end (not during drag)
  </verify>
  <done>
    Gizmo manager handles translate/rotate/scale with snap support. Selection manager provides click, shift-click, and box-select. Grid plane renders. All gizmo transforms produce PatchOps on drag end (one op per gesture).
  </done>
</task>

<task type="auto">
  <name>Task 2: Floating toolbar and keyboard shortcuts</name>
  <files>
    apps/editor/src/components/editor/viewport/floating-toolbar.tsx
    apps/editor/src/components/editor/viewport/viewport-canvas.tsx
    apps/editor/src/hooks/use-keyboard-shortcuts.ts
  </files>
  <action>
    **Floating Toolbar** (`viewport/floating-toolbar.tsx`):
    - Per user decision: editing tools live in a floating toolbar embedded in the viewport (Figma-style), not in the top bar.
    - Position: Bottom-center of the viewport area, floating with subtle shadow and rounded corners.
    - Dark semi-transparent background (glass-morphism style or solid neutral-800/900 with border).
    - Contains:
      - Gizmo mode buttons: Move (Move icon), Rotate (RotateCw icon), Scale (Maximize2 icon). Active mode highlighted with accent color.
      - Separator
      - Snap toggle button (Magnet icon or Grid3x3). Active state when snap enabled.
      - Grid size display/button (shows current grid size, opens small popover to change)
      - Separator
      - Camera mode toggle (Camera icon for orbit, Navigation icon for fly). Shows current mode.
    - All buttons connected to `editorStore` via `useEditorStore` selectors:
      - Gizmo buttons call `setGizmoMode(mode)`
      - Snap toggle calls `toggleSnap()`
      - Camera toggle calls `setCameraMode(mode === 'fly' ? 'orbit' : 'fly')`
    - Use Lucide icons from `lucide-react`.

    **Keyboard Shortcuts** (`hooks/use-keyboard-shortcuts.ts`):
    - Use `react-hotkeys-hook` for binding.
    - Shortcuts (per research discretion recommendations, industry standard):
      - `W` -> translate gizmo
      - `E` -> rotate gizmo
      - `R` -> scale gizmo
      - `Escape` -> deselect all (`setSelection([])`)
      - `Delete` / `Backspace` -> delete selected entities (dispatch DeleteEntity PatchOps)
      - `F` -> focus camera on selected entity (move camera to look at selection center)
      - `F5` or custom -> toggle camera mode
    - Export a `useKeyboardShortcuts()` hook that registers all shortcuts. Call in EditorShell.
    - Guard shortcuts so they don't fire when typing in input fields (react-hotkeys-hook handles this with `enableOnFormTags: false` default).

    **Update viewport-canvas.tsx:** Mount the FloatingToolbar as an overlay on top of the canvas (absolutely positioned within the viewport container). Ensure toolbar receives pointer events but the canvas behind it receives all other pointer events.
  </action>
  <verify>
    - `pnpm typecheck --filter @riff3d/editor` passes
    - `pnpm lint --filter @riff3d/editor` passes
    - Floating toolbar renders at bottom-center of viewport
    - Clicking W/E/R switches gizmo mode (both toolbar button and keyboard)
    - Snap toggle works from toolbar
    - Camera mode toggle works from toolbar
    - Escape deselects
    - Delete key removes selected entity
    - Keyboard shortcuts don't fire in input fields
  </verify>
  <done>
    Figma-style floating toolbar in the viewport with gizmo mode, snap, and camera controls. Keyboard shortcuts registered for all common editor actions (W/E/R for gizmos, Escape for deselect, Delete for remove, F for focus). All interactions dispatch through the store.
  </done>
</task>

</tasks>

<verification>
- Click to select entities in viewport, visual feedback shows selection
- Shift+click toggles multi-selection
- Box/marquee select by dragging in viewport
- Translate gizmo moves entities along axes, produces PatchOp on release
- Rotate gizmo rotates entities, produces PatchOp on release
- Scale gizmo scales entities, produces PatchOp on release
- Snap-to-grid snaps transforms to configured grid size
- Grid plane visible at ground level
- Floating toolbar shows correct state and responds to clicks
- Keyboard shortcuts W/E/R switch gizmo modes
</verification>

<success_criteria>
- Transform gizmos work with RGB axes, configurable snap-to-grid (EDIT-02)
- Grid/snap system with configurable grid size and rotation snap (EDIT-07)
- Entity selection via click, shift-click, and box select works
- Every gizmo transform produces exactly one PatchOp (not one per frame)
- Floating toolbar provides quick access to gizmo mode, snap, and camera controls
</success_criteria>

<output>
After completion, create `.planning/phases/02-closed-loop-editor/02-03-SUMMARY.md`
</output>
