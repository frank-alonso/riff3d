---
phase: 01-contracts-testing-spine
plan: 06
type: execute
wave: 4
depends_on: ["01-03", "01-04", "01-05"]
files_modified:
  - packages/fixtures/src/builders/builder.ts
  - packages/fixtures/src/builders/transforms-parenting.ts
  - packages/fixtures/src/builders/materials-lights.ts
  - packages/fixtures/src/builders/animation.ts
  - packages/fixtures/src/builders/events-triggers.ts
  - packages/fixtures/src/builders/character-stub.ts
  - packages/fixtures/src/builders/timeline-stub.ts
  - packages/fixtures/src/builders/adversarial.ts
  - packages/fixtures/src/builders/index.ts
  - packages/fixtures/src/reference/transforms-parenting.json
  - packages/fixtures/src/index.ts
  - packages/fixtures/__tests__/builders.test.ts
  - packages/fixtures/__tests__/reference-equivalence.test.ts
  - packages/conformance/src/harness.ts
  - packages/conformance/src/round-trip.ts
  - packages/conformance/src/replay.ts
  - packages/conformance/src/benchmarks.ts
  - packages/conformance/src/index.ts
  - packages/conformance/__tests__/round-trip.test.ts
  - packages/conformance/__tests__/replay.test.ts
  - packages/conformance/__tests__/property-tests.test.ts
  - packages/conformance/__tests__/benchmarks.test.ts
autonomous: true
requirements:
  - TEST-01
  - TEST-02
  - TEST-03
  - TEST-05

must_haves:
  truths:
    - "7 golden fixtures exist (6 clean + 1 adversarial), all produced by builder API, all valid per Zod"
    - "A hand-authored reference fixture exists and a test asserts the builder produces identical output"
    - "Round-trip tests pass: ECSON -> compile -> decompile -> compare (portable subset identical)"
    - "Replay determinism tests pass: apply ops to fresh doc twice, results identical"
    - "fast-check property tests verify apply-inverse identity, replay determinism, and batch equivalence for random op sequences"
    - "Performance benchmark infrastructure is operational with defined budgets for compilation time"
    - "The adversarial fixture exercises deep hierarchies, shared materials, event wire chains, and handles edge cases"
    - "The Rapier physics evaluation spike findings are referenced (already completed in .planning/research/RAPIER_SPIKE.md)"
  artifacts:
    - path: "packages/fixtures/src/builders/builder.ts"
      provides: "Fluent SceneBuilder + EntityBuilder API for constructing ECSON documents"
      exports: ["SceneBuilder", "EntityBuilder"]
    - path: "packages/fixtures/src/builders/transforms-parenting.ts"
      provides: "Golden fixture: transforms and parenting hierarchy"
      exports: ["buildTransformsParentingFixture"]
    - path: "packages/fixtures/src/builders/timeline-stub.ts"
      provides: "Golden fixture: multi-track timeline with keyframe sequences across entities"
      exports: ["buildTimelineStubFixture"]
    - path: "packages/fixtures/src/builders/adversarial.ts"
      provides: "Adversarial fixture: deep hierarchy, shared materials, event chains, edge cases"
      exports: ["buildAdversarialFixture"]
    - path: "packages/fixtures/src/reference/transforms-parenting.json"
      provides: "Hand-authored reference fixture for format documentation"
    - path: "packages/conformance/src/harness.ts"
      provides: "Conformance test runner infrastructure"
      exports: ["runConformanceSuite"]
    - path: "packages/conformance/src/round-trip.ts"
      provides: "Round-trip test utilities (ECSON -> IR -> ECSON)"
      exports: ["testRoundTrip"]
    - path: "packages/conformance/src/replay.ts"
      provides: "PatchOps replay determinism test utilities"
      exports: ["testReplayDeterminism"]
    - path: "packages/conformance/src/benchmarks.ts"
      provides: "Performance benchmark runners with budget enforcement"
      exports: ["benchmarkCompilation", "PERFORMANCE_BUDGETS"]
  key_links:
    - from: "packages/fixtures/src/builders/builder.ts"
      to: "packages/ecson/src/schemas/scene-document.ts"
      via: "SceneBuilder.build() validates with SceneDocumentSchema"
      pattern: "SceneDocumentSchema\\.parse"
    - from: "packages/conformance/src/round-trip.ts"
      to: "packages/canonical-ir/src/compiler.ts"
      via: "imports compile/decompile for round-trip testing"
      pattern: "import.*compile.*@riff3d/canonical-ir"
    - from: "packages/conformance/src/replay.ts"
      to: "packages/patchops/src/engine.ts"
      via: "imports applyOps for replay determinism testing"
      pattern: "import.*applyOps.*@riff3d/patchops"
    - from: "packages/conformance/__tests__/property-tests.test.ts"
      to: "fast-check"
      via: "Uses @fast-check/vitest for property-based testing"
      pattern: "test\\.prop"
---

<objective>
Create the golden fixture suite (6 clean + 1 adversarial) using a fluent builder API, implement the conformance harness with round-trip tests, PatchOps replay determinism tests, fast-check property-based tests, and performance benchmark infrastructure. Reference the completed Rapier physics evaluation spike.

Purpose: Golden fixtures and conformance tests are the regression backbone that makes fast iteration safe. Property-based tests catch edge cases that hand-written tests miss. Performance budgets prevent gradual degradation. This plan proves the entire Phase 1 contract stack works end-to-end.

Output: The `@riff3d/fixtures` package exports builder API and 7 fixture generators. The `@riff3d/conformance` package exports harness, round-trip, replay, benchmark utilities. All conformance tests pass. Rapier spike findings are documented and referenced.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-contracts-testing-spine/01-RESEARCH.md
@.planning/phases/01-contracts-testing-spine/01-03-SUMMARY.md
@.planning/phases/01-contracts-testing-spine/01-04-SUMMARY.md
@.planning/phases/01-contracts-testing-spine/01-05-SUMMARY.md
@.planning/research/RAPIER_SPIKE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement builder API and create 7 golden fixtures with hand-authored reference</name>
  <files>
    packages/fixtures/src/builders/builder.ts
    packages/fixtures/src/builders/transforms-parenting.ts
    packages/fixtures/src/builders/materials-lights.ts
    packages/fixtures/src/builders/animation.ts
    packages/fixtures/src/builders/events-triggers.ts
    packages/fixtures/src/builders/character-stub.ts
    packages/fixtures/src/builders/timeline-stub.ts
    packages/fixtures/src/builders/adversarial.ts
    packages/fixtures/src/builders/index.ts
    packages/fixtures/src/reference/transforms-parenting.json
    packages/fixtures/src/index.ts
    packages/fixtures/__tests__/builders.test.ts
    packages/fixtures/__tests__/reference-equivalence.test.ts
  </files>
  <action>
    1. **Builder API** (`packages/fixtures/src/builders/builder.ts`):
       Implement a fluent, nested API:

       ```typescript
       class SceneBuilder {
         static create(name: string): SceneBuilder;
         addEntity(name: string, opts?: { tags?: string[] }): EntityBuilder;
         addAsset(type: AssetType, name: string, opts?: { uri?: string }): string; // returns assetId
         addWire(wire: { sourceEntityId: string; sourceEvent: string; targetEntityId: string; targetAction: string; parameters?: Record<string, unknown> }): this;
         setEnvironment(env: Partial<EnvironmentSettings>): this;
         setGameSettings(settings: Partial<GameSettings>): this;
         build(): SceneDocument; // validates with Zod, throws on invalid
       }

       class EntityBuilder {
         addComponent(type: string, properties?: Record<string, unknown>): this;
         setTransform(transform: Partial<Transform>): this;
         setTags(tags: string[]): this;
         setTuning(engine: string, properties: Record<string, unknown>): this;
         addChild(name: string, opts?: { tags?: string[] }): EntityBuilder; // nested fluent
         done(): SceneBuilder; // return to parent
         getId(): string; // get this entity's generated ID
       }
       ```

       The builder uses nested fluent API for authoring ergonomics but `build()` produces a FLAT entity map (ECSON format). Internally, track the tree structure and flatten on build.

       The builder MUST call `SceneDocumentSchema.parse()` on the final output to ensure validity.

       Use deterministic IDs in fixtures (seeded or hardcoded) so fixtures are reproducible. Create a `createDeterministicIdGenerator(seed: string)` that produces predictable IDs for test reproducibility.

    2. **6 Clean Fixtures** (one builder file each):

       **transforms-parenting.ts** (`buildTransformsParentingFixture()`):
       - Root entity at origin
       - 3-level hierarchy (Root -> Parent A -> Child A1, A2; Root -> Parent B -> Child B1)
       - Varied transforms: positions, rotations, non-uniform scales
       - MeshRenderer components on leaf entities (box, sphere, cylinder)
       - Structural-only (no asset references beyond primitives)
       - Purpose: Tests hierarchy traversal, transform inheritance, parenting

       **materials-lights.ts** (`buildMaterialsLightsFixture()`):
       - Scene with 3 entities sharing the same material asset
       - One directional light, one point light, one spot light
       - One entity with an unlit material (KHR_materials_unlit coverage)
       - Material asset with full PBR properties (metallic, roughness, emissive)
       - Texture asset references (baseColorMap, normalMap) -- URIs point to test paths
       - Purpose: Tests material sharing, light types, PBR properties, asset references

       **animation.ts** (`buildAnimationFixture()`):
       - Entity with Animation component
       - Two clip references (walk, idle)
       - Default clip set
       - Basic transform keyframe data in the animation
       - Purpose: Tests animation component schema, clip references

       **events-triggers.ts** (`buildEventsTriggersFixture()`):
       - TriggerZone entity wired to ScoreZone entity (onEnter -> activate)
       - Timer entity wired to Spawner entity (onComplete -> spawn)
       - KillZone with respawn behavior
       - 3-step event chain: TriggerZone.onEnter -> Timer.start -> Spawner.spawn
       - Purpose: Tests event wiring, cross-entity connections, gameplay components

       **character-stub.ts** (`buildCharacterStubFixture()`):
       - Character entity with MeshRenderer, RigidBody, Collider (capsule), Animation
       - Checkpoint entities (3, ordered)
       - MovingPlatform entity
       - PathFollower entity with waypoint references
       - Purpose: Tests character components, gameplay stubs, entity references

       **timeline-stub.ts** (`buildTimelineStubFixture()`):
       - Scene with 3 entities, each with Animation components
       - Multi-track timeline: entity A has position + rotation tracks, entity B has scale track, entity C has material color track
       - Each track has 3-5 keyframes at different times with interpolation metadata
       - Timeline metadata: duration, loop mode, playback speed
       - Cross-entity synchronization: all tracks share a common timeline duration
       - Keyframe data uses the animation keyframe schema (time, value, interpolation type)
       - Purpose: Tests multi-track timeline data, keyframe sequences across entities, timeline metadata -- distinct from the simple animation fixture which tests component/clip references

    3. **Adversarial Fixture** (`buildAdversarialFixture()`):
       - 6+ level deep hierarchy with varied branch widths
       - 3 entities sharing the same material asset (SharedMaterial pattern)
       - 3-step cross-entity event wire chain (A triggers B triggers C)
       - Empty entities (no components) at various levels -- must survive round-trip
       - Unicode entity names: emoji, CJK characters, RTL text
       - Entities with maximum component count (all component types on one entity)
       - Engine tuning sections on selected entities and components
       - Deeply nested component properties (for path-based SetProperty testing)
       - Game settings populated with non-default values
       - Purpose: Exercises edge cases, deep paths, shared references, encoding, maximum complexity

    4. **Hand-authored reference** (`packages/fixtures/src/reference/transforms-parenting.json`):
       Write the transforms-parenting fixture as hand-authored JSON. This serves as format documentation for humans reading the ECSON format.

    5. **Reference equivalence test** (`packages/fixtures/__tests__/reference-equivalence.test.ts`):
       Assert that `buildTransformsParentingFixture()` output matches the hand-authored JSON (after normalization). This proves the builder is correct and keeps the reference in sync.

    6. **Builder tests** (`packages/fixtures/__tests__/builders.test.ts`):
       - Each of the 7 builders produces a valid SceneDocument (Zod parse succeeds)
       - Transforms-parenting has correct hierarchy depth and entity count
       - Materials-lights has 3 entities sharing one material asset
       - Timeline-stub has 3 entities with multi-track keyframe data and shared timeline duration
       - Adversarial has 6+ levels of nesting
       - Adversarial has unicode entity names
       - Adversarial has empty entities
       - All fixtures have unique entity IDs (no duplicates)

    7. **Barrel exports**: `builders/index.ts` and `fixtures/src/index.ts` export all 7 builders and the builder API.
  </action>
  <verify>
    `pnpm --filter @riff3d/fixtures test` passes all builder and reference equivalence tests.
    `pnpm --filter @riff3d/fixtures typecheck` passes.
    All 7 fixtures produce valid SceneDocuments per Zod.
    Reference equivalence test confirms builder matches hand-authored JSON.
  </verify>
  <done>
    7 golden fixtures exist (6 clean + 1 adversarial), all produced by the fluent builder API, all Zod-validated. The 6 clean fixtures cover: transforms+parenting, materials+lights, simple animation, events/triggers, character stub, and timeline stub. A hand-authored reference fixture documents the format and a test proves builder equivalence. The builder API supports nested fluent construction that flattens to ECSON's entity record format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement conformance harness, round-trip tests, replay determinism, and fast-check property tests</name>
  <files>
    packages/conformance/src/harness.ts
    packages/conformance/src/round-trip.ts
    packages/conformance/src/replay.ts
    packages/conformance/src/index.ts
    packages/conformance/__tests__/round-trip.test.ts
    packages/conformance/__tests__/replay.test.ts
    packages/conformance/__tests__/property-tests.test.ts
  </files>
  <action>
    1. **Conformance Harness** (`packages/conformance/src/harness.ts`):
       - `runConformanceSuite(fixtures: SceneDocument[]): ConformanceResult`:
         - Runs round-trip tests on each fixture
         - Reports pass/fail per fixture with detailed diffs on failure
         - Returns aggregate results
       - `ConformanceResult` type: `{ passed: number, failed: number, results: { fixture: string, roundTrip: boolean, errors: string[] }[] }`
       - Use json-stable-stringify for deterministic comparison

    2. **Round-trip utilities** (`packages/conformance/src/round-trip.ts`):
       - `testRoundTrip(doc: SceneDocument): { passed: boolean; diff?: string }`:
         - Compile to IR, decompile back to ECSON
         - Compare portable subset fields using deep equality with normalized key ordering
         - Return pass/fail with diff on failure
       - `normalizeForComparison(doc: SceneDocument): string`:
         - Sort entity keys, sort component arrays, use json-stable-stringify
         - Used for deterministic snapshot comparison

    3. **Replay determinism** (`packages/conformance/src/replay.ts`):
       - `testReplayDeterminism(ops: PatchOp[]): { passed: boolean; diff?: string }`:
         - Create empty document, apply ops -> result1
         - Create fresh empty document, apply same ops -> result2
         - Compare result1 and result2 using `normalizeForComparison`
         - Return pass/fail with diff on failure
       - `generateOpsForFixture(fixture: SceneDocument): PatchOp[]`:
         - Given a fixture, generate the PatchOps that would build it from scratch
         - CreateEntity for each entity, AddComponent for each component, AddAsset for each asset, etc.
         - This is the "reverse engineering" of a fixture into an op log

    4. **Round-trip tests** (`packages/conformance/__tests__/round-trip.test.ts`):
       - Test each of the 7 golden fixtures through ECSON -> IR -> ECSON round-trip
       - Assert portable subset is preserved identically
       - Assert engine tuning is preserved
       - Assert adversarial fixture survives round-trip (empty entities, unicode names, deep hierarchy)

    5. **Replay determinism tests** (`packages/conformance/__tests__/replay.test.ts`):
       - Generate ops for transforms-parenting fixture
       - Apply ops to empty doc twice
       - Assert identical results
       - Generate ops for adversarial fixture
       - Apply ops twice, assert identical
       - Test with interleaved ops (create, modify, delete, create again)

    6. **fast-check property tests** (`packages/conformance/__tests__/property-tests.test.ts`):
       Using `@fast-check/vitest` and `fast-check`:

       Create custom arbitraries:
       - `entityIdArb`: `fc.stringOf(fc.constantFrom(...alphanumChars), { minLength: 16, maxLength: 16 })`
       - `vec3Arb`: `fc.record({ x: fc.float(), y: fc.float(), z: fc.float() })`
       - `createEntityOpArb`: generates valid CreateEntity ops
       - `setPropertyOpArb`: generates valid SetProperty ops targeting existing entities
       - `addComponentOpArb`: generates valid AddComponent ops
       - `batchOpArb`: generates BatchOp with 1-5 sub-ops

       **Property 1: Apply-inverse identity**
       ```
       test.prop([opSequenceArb])(
         'applying ops then their inverses returns to original state',
         ([ops]) => { ... }
       );
       ```
       Apply ops, collect inverses, apply inverses in reverse order, assert doc equals original.

       **Property 2: Replay determinism**
       ```
       test.prop([opSequenceArb])(
         'replaying same ops on fresh docs produces identical results',
         ([ops]) => { ... }
       );
       ```

       **Property 3: Batch equivalence**
       ```
       test.prop([opSequenceArb])(
         'applying ops individually equals applying them as a BatchOp',
         ([ops]) => { ... }
       );
       ```

       **Property 4: Structural integrity**
       ```
       test.prop([opSequenceArb])(
         'after any valid op sequence, the document is still valid per Zod',
         ([ops]) => { ... }
       );
       ```

       **IMPORTANT**: Use model-based testing (`fc.commands` pattern) or stateful arbitraries that track which entities exist, so generated ops are valid against the current document state. Without this, ops will reference non-existent entities and fail.

       Configure fast-check with a fixed seed for reproducibility in CI, but also run with random seed locally for discovery.
  </action>
  <verify>
    `pnpm --filter @riff3d/conformance test` passes ALL tests (round-trip, replay, property tests).
    `pnpm --filter @riff3d/conformance typecheck` passes.
    Round-trip tests pass for all 7 golden fixtures.
    Property tests run at least 100 iterations per property.
    All tests pass deterministically in CI (fixed seed).
  </verify>
  <done>
    Conformance harness is operational with round-trip tests (all 7 fixtures pass), replay determinism tests, and fast-check property tests proving apply-inverse identity, replay determinism, batch equivalence, and structural integrity for random op sequences. The testing spine is proven.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement performance benchmark infrastructure and document Rapier spike reference</name>
  <files>
    packages/conformance/src/benchmarks.ts
    packages/conformance/__tests__/benchmarks.test.ts
    packages/conformance/src/index.ts
  </files>
  <action>
    1. **Performance benchmarks** (`packages/conformance/src/benchmarks.ts`):
       Define performance budgets and benchmark utilities using Vitest's built-in benchmark API.

       ```typescript
       export const PERFORMANCE_BUDGETS = {
         compilationTime: {
           smallFixture: 50,    // ms -- 1-10 entities
           mediumFixture: 200,  // ms -- 10-50 entities
           largeFixture: 1000,  // ms -- 50-200 entities
         },
         decompilationTime: {
           smallFixture: 50,
           mediumFixture: 200,
           largeFixture: 1000,
         },
         patchOpApply: {
           singleOp: 1,        // ms
           batchOf100: 50,     // ms
         },
         memoryBaseline: {
           emptyDocument: 1024 * 50,  // 50KB
           largeFixture: 1024 * 500,  // 500KB
         },
       };

       export function benchmarkCompilation(fixture: SceneDocument): { timeMs: number; memoryBytes: number };
       export function benchmarkDecompilation(ir: CanonicalScene): { timeMs: number; memoryBytes: number };
       export function benchmarkOpApplication(doc: SceneDocument, ops: PatchOp[]): { timeMs: number; opsPerSecond: number };
       ```

       Use `performance.now()` for timing and `process.memoryUsage().heapUsed` for memory.

    2. **Benchmark tests** (`packages/conformance/__tests__/benchmarks.test.ts`):
       - Benchmark compilation of each golden fixture (log timing, assert under budget)
       - Benchmark decompilation of each fixture's IR
       - Benchmark applying 100 PatchOps sequentially
       - Benchmark applying a BatchOp of 100 sub-ops
       - Use Vitest's `describe.skip` or a dedicated bench config so benchmarks don't run on every `pnpm test` by default -- only on explicit `pnpm --filter @riff3d/conformance bench` or in CI with a benchmark flag

       NOTE: Budget assertions should use generous margins for CI environments (2x the defined budget) since CI machines vary in performance. The budgets are baselines for tracking trends, not hard gates initially.

    3. **Rapier spike reference**:
       The Rapier physics evaluation spike is already completed at `.planning/research/RAPIER_SPIKE.md`. No new work needed -- just document in the conformance package README or index that the spike findings informed the RigidBody and Collider component schemas.

       Add a comment in `packages/conformance/src/index.ts`:
       ```typescript
       /**
        * Physics evaluation: Rapier.js spike completed.
        * See .planning/research/RAPIER_SPIKE.md for findings.
        * Decision: Use @dimforge/rapier3d-compat v0.19.x as web runtime physics adapter.
        * Physics contracts (RigidBody, Collider schemas) are engine-agnostic per spike recommendations.
        */
       ```

    4. **Update conformance src/index.ts**: Export harness, round-trip, replay, benchmarks.
  </action>
  <verify>
    `pnpm --filter @riff3d/conformance typecheck` passes.
    Benchmark utilities compile and can be invoked (even if actual benchmark runs are gated behind a flag).
    `pnpm turbo typecheck lint test` passes for full monorepo.
    Performance budgets are defined and documented.
  </verify>
  <done>
    Performance benchmark infrastructure is operational with defined budgets for compilation time, decompilation time, op application speed, and memory usage. Benchmarks can be run explicitly against golden fixtures. The Rapier physics evaluation spike is documented and its findings referenced in the conformance package. All Phase 1 success criteria for TEST-05 are met.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @riff3d/fixtures test` -- all fixture builder tests pass
- `pnpm --filter @riff3d/conformance test` -- round-trip, replay, and property tests pass
- All 7 golden fixtures round-trip through ECSON -> IR -> ECSON
- fast-check property tests run 100+ iterations per property
- Reference equivalence test passes (builder matches hand-authored JSON)
- Performance budgets defined and benchmark infrastructure operational
- `pnpm turbo typecheck lint test` -- full monorepo green
</verification>

<success_criteria>
The golden fixture suite and conformance harness prove the entire Phase 1 contract stack works end-to-end. Round-trip fidelity is proven for all fixtures. PatchOps replay determinism is proven. Property-based tests cover invariants with random inputs. Performance budgets establish baselines. The Rapier spike findings are integrated.
</success_criteria>

<output>
After completion, create `.planning/phases/01-contracts-testing-spine/01-06-SUMMARY.md`
</output>
