---
phase: 01-contracts-testing-spine
plan: 03
type: tdd
wave: 3
depends_on: ["01-02"]
files_modified:
  - packages/patchops/src/schemas.ts
  - packages/patchops/src/origin.ts
  - packages/patchops/src/version.ts
  - packages/patchops/src/ops/create-entity.ts
  - packages/patchops/src/ops/delete-entity.ts
  - packages/patchops/src/ops/set-property.ts
  - packages/patchops/src/ops/add-child.ts
  - packages/patchops/src/ops/remove-child.ts
  - packages/patchops/src/ops/reparent.ts
  - packages/patchops/src/ops/add-component.ts
  - packages/patchops/src/ops/remove-component.ts
  - packages/patchops/src/ops/set-component-property.ts
  - packages/patchops/src/ops/add-asset.ts
  - packages/patchops/src/ops/remove-asset.ts
  - packages/patchops/src/ops/replace-asset-ref.ts
  - packages/patchops/src/ops/add-keyframe.ts
  - packages/patchops/src/ops/remove-keyframe.ts
  - packages/patchops/src/ops/set-keyframe-value.ts
  - packages/patchops/src/ops/batch-op.ts
  - packages/patchops/src/ops/index.ts
  - packages/patchops/src/engine.ts
  - packages/patchops/src/validation.ts
  - packages/patchops/src/index.ts
  - packages/patchops/__tests__/schemas.test.ts
  - packages/patchops/__tests__/engine.test.ts
  - packages/patchops/__tests__/inverse.test.ts
autonomous: true
requirements:
  - CORE-01
  - CORE-02

must_haves:
  truths:
    - "All 16 PatchOp types are defined as Zod schemas in a discriminated union on the 'type' field"
    - "Every PatchOp carries an id (nanoid), timestamp, origin (user/AI/system/replay), and version field"
    - "Applying any PatchOp to a valid ECSON document produces a valid ECSON document"
    - "Every PatchOp type has an inverse generator that produces an op which undoes the original"
    - "Applying an op then its inverse returns the document to its original state (tested for all 16 types)"
    - "Replaying the same sequence of ops on two fresh documents produces identical results"
    - "BatchOp applies all sub-ops atomically and its inverse is a BatchOp of sub-inverses in reverse order"
    - "Reparent validates against circular references (reparenting under own descendant is rejected)"
  artifacts:
    - path: "packages/patchops/src/schemas.ts"
      provides: "Zod discriminated union of all 16 PatchOp types"
      contains: "PatchOpSchema"
    - path: "packages/patchops/src/engine.ts"
      provides: "applyOp, applyOps functions that mutate ECSON and return inverses"
      exports: ["applyOp", "applyOps"]
    - path: "packages/patchops/src/origin.ts"
      provides: "Origin enum and safe mode configuration"
      contains: "OriginSchema"
    - path: "packages/patchops/src/version.ts"
      provides: "PatchOp format version constants"
      contains: "CURRENT_PATCHOP_VERSION"
    - path: "packages/patchops/src/validation.ts"
      provides: "Pre-apply validation (circular reparent check, entity existence, etc.)"
      exports: ["validateOp"]
  key_links:
    - from: "packages/patchops/src/engine.ts"
      to: "packages/ecson/src/schemas/scene-document.ts"
      via: "imports SceneDocument type for mutation target"
      pattern: "import.*SceneDocument.*@riff3d/ecson"
    - from: "packages/patchops/src/schemas.ts"
      to: "packages/patchops/src/ops/*.ts"
      via: "discriminatedUnion members from each op file"
      pattern: "z\\.discriminatedUnion"
    - from: "packages/patchops/src/engine.ts"
      to: "packages/patchops/src/validation.ts"
      via: "pre-apply validation before mutation"
      pattern: "validateOp"
---

<objective>
Implement the complete PatchOps system: 16 operation types as a Zod discriminated union, the apply engine that mutates ECSON documents, inverse generation for every op type, origin categories (user/AI/system/replay), format versioning, and pre-apply validation including circular reparent detection.

Purpose: PatchOps are the atomic edit language -- every mutation to an ECSON document MUST flow through them. Getting the apply/inverse cycle correct and tested is critical for undo/redo, collaboration, and AI authoring.

Output: The `@riff3d/patchops` package exports PatchOp schemas, `applyOp`/`applyOps` functions, inverse generators, origin/version utilities, and comprehensive tests proving apply-inverse identity for all 16 op types.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-contracts-testing-spine/01-RESEARCH.md
@.planning/phases/01-contracts-testing-spine/01-02-SUMMARY.md

Prototype reference:
@/home/frank/riff3d-prototype/.planning/rebuild-research/FOUNDATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define PatchOp Zod schemas (all 16 types), origin policy, and format versioning</name>
  <files>
    packages/patchops/src/origin.ts
    packages/patchops/src/version.ts
    packages/patchops/src/ops/create-entity.ts
    packages/patchops/src/ops/delete-entity.ts
    packages/patchops/src/ops/set-property.ts
    packages/patchops/src/ops/add-child.ts
    packages/patchops/src/ops/remove-child.ts
    packages/patchops/src/ops/reparent.ts
    packages/patchops/src/ops/add-component.ts
    packages/patchops/src/ops/remove-component.ts
    packages/patchops/src/ops/set-component-property.ts
    packages/patchops/src/ops/add-asset.ts
    packages/patchops/src/ops/remove-asset.ts
    packages/patchops/src/ops/replace-asset-ref.ts
    packages/patchops/src/ops/add-keyframe.ts
    packages/patchops/src/ops/remove-keyframe.ts
    packages/patchops/src/ops/set-keyframe-value.ts
    packages/patchops/src/ops/batch-op.ts
    packages/patchops/src/ops/index.ts
    packages/patchops/src/schemas.ts
    packages/patchops/src/index.ts
    packages/patchops/__tests__/schemas.test.ts
  </files>
  <action>
    **TDD: Write schema tests FIRST, then implement schemas to pass them.**

    **RED phase -- write failing tests first** (`packages/patchops/__tests__/schemas.test.ts`):
    - PatchOpSchema validates a CreateEntity op with all required fields
    - PatchOpSchema rejects an op with unknown type
    - Each of the 16 op types validates with correct payload
    - Origin field accepts exactly `user`, `ai`, `system`, `replay`
    - Version field defaults to CURRENT_PATCHOP_VERSION
    - All ops have `id`, `timestamp`, `origin`, `version` fields
    - BatchOp contains an array of sub-ops

    **GREEN phase -- implement schemas:**

    1. **origin.ts**: Define `OriginSchema = z.enum(['user', 'ai', 'system', 'replay'])`. Define `SafeModeConfig` schema with `enabled: boolean (default false)`, `restrictedOps: string[]` (op types AI cannot execute in safe mode). Export `type Origin`.

    2. **version.ts**: `CURRENT_PATCHOP_VERSION = 1`. Export constant.

    3. **Shared base fields** (in schemas.ts or a shared file):
       ```typescript
       const PatchOpBase = {
         id: z.string(),           // nanoid
         timestamp: z.number(),
         origin: OriginSchema,
         version: z.number().default(CURRENT_PATCHOP_VERSION),
       };
       ```

    4. **Each op file** (one per `packages/patchops/src/ops/{name}.ts`):
       Export a Zod schema with `...PatchOpBase` spread + `type: z.literal('OpName')` + `payload: z.object({...})`.

       **Payloads (specify exactly):**
       - **CreateEntity**: `{ entityId, name, parentId: string|null, transform?: Transform, tags?: string[] }`
       - **DeleteEntity**: `{ entityId, previousState: Entity }` (previousState for inverse)
       - **SetProperty**: `{ entityId, path: string, value: unknown, previousValue: unknown }` (path is dot-separated, e.g. `"transform.position.x"`)
       - **AddChild**: `{ parentId, childId, index?: number }` (index for insertion position)
       - **RemoveChild**: `{ parentId, childId, previousIndex: number }` (previousIndex for inverse)
       - **Reparent**: `{ entityId, newParentId: string|null, oldParentId: string|null, oldIndex: number, newIndex?: number }`
       - **AddComponent**: `{ entityId, component: ComponentInstance }`
       - **RemoveComponent**: `{ entityId, componentType: string, previousComponent: ComponentInstance }`
       - **SetComponentProperty**: `{ entityId, componentType: string, propertyPath: string, value: unknown, previousValue: unknown }`
       - **AddAsset**: `{ asset: AssetEntry }`
       - **RemoveAsset**: `{ assetId: string, previousAsset: AssetEntry }`
       - **ReplaceAssetRef**: `{ entityId, componentType: string, propertyPath: string, newAssetId: string, oldAssetId: string }`
       - **AddKeyframe**: `{ entityId, trackId: string, time: number, value: unknown }`
       - **RemoveKeyframe**: `{ entityId, trackId: string, time: number, previousValue: unknown }`
       - **SetKeyframeValue**: `{ entityId, trackId: string, time: number, value: unknown, previousValue: unknown }`
       - **BatchOp**: `{ ops: PatchOp[] }` (recursive -- uses the discriminated union)

    5. **schemas.ts**: Create the discriminated union:
       ```typescript
       export const PatchOpSchema = z.discriminatedUnion('type', [
         CreateEntityOpSchema,
         DeleteEntityOpSchema,
         // ... all 16
       ]);
       export type PatchOp = z.infer<typeof PatchOpSchema>;
       ```

       **NOTE on BatchOp recursion:** Zod's `z.lazy()` is needed for BatchOp since it contains PatchOp[]. Define BatchOp using `z.lazy(() => PatchOpSchema)` for the ops array.

    6. **ops/index.ts**: Barrel export all op schemas.
    7. **Update packages/patchops/src/index.ts**: Export schemas, types, origin, version.

    Run tests -- they should all pass.
  </action>
  <verify>
    `pnpm --filter @riff3d/patchops test` passes all schema tests.
    `pnpm --filter @riff3d/patchops typecheck` passes.
  </verify>
  <done>
    All 16 PatchOp types are defined as Zod schemas with a discriminated union on `type`. Each op has id, timestamp, origin (user/AI/system/replay), and version fields. Schema tests validate all op types, reject invalid ops, and verify origin/version handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement PatchOps engine (applyOp, inverse generation, validation) with TDD</name>
  <files>
    packages/patchops/src/engine.ts
    packages/patchops/src/validation.ts
    packages/patchops/__tests__/engine.test.ts
    packages/patchops/__tests__/inverse.test.ts
    packages/patchops/src/index.ts
  </files>
  <action>
    **TDD: Write engine and inverse tests FIRST, then implement to pass them.**

    **RED phase -- write failing tests:**

    `engine.test.ts`:
    - CreateEntity: adds entity to document, returns DeleteEntity inverse
    - DeleteEntity: removes entity from document, returns CreateEntity inverse
    - SetProperty: updates property at path, returns SetProperty inverse with old value
    - AddChild: adds childId to parent's children array, returns RemoveChild inverse
    - RemoveChild: removes childId from parent's children, returns AddChild inverse
    - Reparent: moves entity to new parent, updates both parents' children arrays, returns Reparent inverse
    - AddComponent: adds component to entity, returns RemoveComponent inverse
    - RemoveComponent: removes component from entity, returns AddComponent inverse
    - SetComponentProperty: updates component property, returns SetComponentProperty inverse
    - AddAsset: adds asset to document, returns RemoveAsset inverse
    - RemoveAsset: removes asset, returns AddAsset inverse
    - ReplaceAssetRef: updates asset reference, returns ReplaceAssetRef inverse
    - AddKeyframe, RemoveKeyframe, SetKeyframeValue: similar patterns
    - BatchOp: applies all sub-ops, returns BatchOp inverse with sub-inverses in reverse order
    - applyOps: applies a sequence of ops, returns array of inverses

    `inverse.test.ts` (apply-inverse identity for ALL 16 types):
    - For each op type: create a document, apply op, then apply inverse. Assert document equals original.
    - Special cases:
      - Reparent inverse restores original parent AND sibling order
      - BatchOp inverse restores document to pre-batch state
      - DeleteEntity inverse restores entity with all components and children references

    **GREEN phase -- implement:**

    1. **validation.ts**:
       - `validateOp(doc: SceneDocument, op: PatchOp): { valid: boolean; error?: string }`:
         - Check entity exists (for ops that reference entities)
         - Check entity does NOT exist (for CreateEntity)
         - Check circular reparent: walk up ancestor chain from newParentId, reject if entityId is found
         - Check component exists/doesn't exist (for AddComponent/RemoveComponent)
         - Check asset exists/doesn't exist (for AddAsset/RemoveAsset)
       - Export `validateOp`.

    2. **engine.ts**:
       - `applyOp(doc: SceneDocument, op: PatchOp): PatchOp`:
         - Validate op first via `validateOp()`. Throw on invalid.
         - Switch on `op.type` (exhaustive switch using TypeScript never trick).
         - Mutate `doc` in place (caller is responsible for cloning if needed).
         - Return the inverse op (with new nanoid, same origin as `replay`, current timestamp).
       - `applyOps(doc: SceneDocument, ops: PatchOp[]): PatchOp[]`:
         - Apply each op in sequence, collect inverses.
         - Return inverses array.

       **Implementation details per op:**
       - **CreateEntity**: Add entity to `doc.entities`, add childId to parent's children. Inverse: DeleteEntity with full entity state.
       - **DeleteEntity**: Capture full entity state, remove from parent's children, delete from entities map. Inverse: CreateEntity with captured state. If entity has children, they become orphaned -- the op should recursively capture them or require children to be removed first (prefer: require children removed first, validate this).
       - **SetProperty**: Use dot-path to traverse entity and set value. Capture previous value. Use a `getByPath`/`setByPath` utility.
       - **AddChild/RemoveChild**: Modify parent's `children` array.
       - **Reparent**: Update entity's `parentId`, remove from old parent's children (capturing index), add to new parent's children (at specified index or end).
       - **AddComponent/RemoveComponent**: Add to/remove from entity's `components` array, matching by `type`.
       - **SetComponentProperty**: Find component by type, use dot-path to set property.
       - **AddAsset/RemoveAsset**: Add to/remove from `doc.assets` record.
       - **ReplaceAssetRef**: Find the component property that references the asset, update it.
       - **Keyframe ops**: These operate on animation component data within entities.
       - **BatchOp**: Apply sub-ops sequentially, collect sub-inverses, return BatchOp with reversed sub-inverses.

       **Path utility** (`getByPath`, `setByPath`): Implement as helper in engine.ts or a utils file. Handles dot-separated paths like `"transform.position.x"` or `"components.Light.intensity"`.

    3. **Update index.ts**: Export `applyOp`, `applyOps`, `validateOp`.

    Run all tests -- they should pass.

    **REFACTOR phase:** Clean up any duplication in the per-op handlers.
  </action>
  <verify>
    `pnpm --filter @riff3d/patchops test` passes ALL tests (schemas + engine + inverse).
    `pnpm --filter @riff3d/patchops typecheck` passes.
    `pnpm turbo typecheck lint test` passes for the full monorepo.
    Every op type has at least one apply test and one apply-inverse identity test.
  </verify>
  <done>
    The PatchOps engine is fully implemented: `applyOp` handles all 16 op types, returns inverses, validates before applying (including circular reparent detection). Apply-inverse identity is proven for every op type. BatchOp works recursively. The engine mutates ECSON documents deterministically.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @riff3d/patchops test` -- all tests pass
- `pnpm --filter @riff3d/patchops typecheck` -- no type errors
- Each of the 16 op types has: schema test, apply test, inverse test
- Reparent circular detection tested with positive and negative cases
- BatchOp tested with multiple sub-ops
- Full monorepo pipeline passes
</verification>

<success_criteria>
The @riff3d/patchops package fully implements the PatchOps contract: 16 deterministic, serializable, invertible operation types. The apply engine mutates ECSON documents safely with validation. Every op's inverse is proven correct by tests. Origin categories and format versioning are in place.
</success_criteria>

<output>
After completion, create `.planning/phases/01-contracts-testing-spine/01-03-SUMMARY.md`
</output>
