---
phase: 01-contracts-testing-spine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/ecson/src/schemas/vec3.ts
  - packages/ecson/src/schemas/quaternion.ts
  - packages/ecson/src/schemas/transform.ts
  - packages/ecson/src/schemas/component-instance.ts
  - packages/ecson/src/schemas/entity.ts
  - packages/ecson/src/schemas/asset.ts
  - packages/ecson/src/schemas/wiring.ts
  - packages/ecson/src/schemas/environment.ts
  - packages/ecson/src/schemas/game-settings.ts
  - packages/ecson/src/schemas/scene-document.ts
  - packages/ecson/src/schemas/engine-tuning.ts
  - packages/ecson/src/schemas/index.ts
  - packages/ecson/src/ids.ts
  - packages/ecson/src/migrations/migrate.ts
  - packages/ecson/src/migrations/versions/.gitkeep
  - packages/ecson/src/index.ts
  - packages/ecson/__tests__/schemas.test.ts
  - packages/ecson/__tests__/ids.test.ts
  - packages/ecson/__tests__/migrations.test.ts
autonomous: true
requirements:
  - CORE-03
  - CORE-04
  - CORE-08
  - CORE-09

must_haves:
  truths:
    - "A valid ECSON SceneDocument can be constructed, validated by Zod, and its TypeScript type is inferred from the schema"
    - "Entity IDs, asset IDs, and operation IDs are globally unique nanoid strings"
    - "ECSON documents carry a schemaVersion field and the migration runner can migrate documents forward"
    - "Engine tuning sections exist at entity and component levels, keyed by engine name"
    - "All ECSON types are derived from Zod schemas via z.infer -- no manually written interfaces"
  artifacts:
    - path: "packages/ecson/src/schemas/scene-document.ts"
      provides: "Root ECSON document schema with version, entities, assets, wiring, environment"
      contains: "SceneDocumentSchema"
    - path: "packages/ecson/src/schemas/entity.ts"
      provides: "Entity schema with stable ID, name, parentId, components, tags, transform, tuning"
      contains: "EntitySchema"
    - path: "packages/ecson/src/schemas/transform.ts"
      provides: "Transform schema with position (Vec3), rotation (Quaternion), scale (Vec3)"
      contains: "TransformSchema"
    - path: "packages/ecson/src/schemas/engine-tuning.ts"
      provides: "Engine tuning schema supporting per-engine sections that can add/override properties"
      contains: "EngineTuningSchema"
    - path: "packages/ecson/src/ids.ts"
      provides: "nanoid-based ID generators for entities, operations, and assets"
      exports: ["generateEntityId", "generateOpId", "generateAssetId"]
    - path: "packages/ecson/src/migrations/migrate.ts"
      provides: "Forward migration runner with version-keyed up() functions"
      exports: ["migrateDocument"]
  key_links:
    - from: "packages/ecson/src/schemas/scene-document.ts"
      to: "packages/ecson/src/schemas/entity.ts"
      via: "z.record import for entities map"
      pattern: "EntitySchema"
    - from: "packages/ecson/src/schemas/entity.ts"
      to: "packages/ecson/src/schemas/component-instance.ts"
      via: "components array uses ComponentInstanceSchema"
      pattern: "ComponentInstanceSchema"
    - from: "packages/ecson/src/schemas/entity.ts"
      to: "packages/ecson/src/schemas/engine-tuning.ts"
      via: "tuning field for per-engine overrides"
      pattern: "EngineTuningSchema"
    - from: "packages/ecson/src/index.ts"
      to: "all schema files"
      via: "barrel re-exports"
      pattern: "export.*from.*schemas"
---

<objective>
Implement the complete ECSON schema as Zod validators: all core types (Vec3, Quaternion, Transform, ComponentInstance, Entity, Asset, EventWire, Environment, GameSettings, SceneDocument), the engine tuning escape hatch schema, nanoid-based ID generation, and the forward migration infrastructure.

Purpose: ECSON is the editor source of truth and the input to everything else (PatchOps operate on it, the compiler reads it). Getting these schemas right -- with Zod as the single source of truth -- is the foundation all other plans depend on.

Output: The `@riff3d/ecson` package exports all ECSON types (derived from Zod via `z.infer<>`), ID generators, and a migration runner. All schemas are validated by tests.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-contracts-testing-spine/01-RESEARCH.md
@.planning/phases/01-contracts-testing-spine/01-01-SUMMARY.md

Prototype reference (read for type foundations, do NOT copy verbatim):
@/home/frank/riff3d-prototype/.planning/rebuild-research/FOUNDATION.md
@/home/frank/riff3d-prototype/.planning/rebuild-research/00-universal-schema-research.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement core ECSON schemas (Vec3 through SceneDocument)</name>
  <files>
    packages/ecson/src/schemas/vec3.ts
    packages/ecson/src/schemas/quaternion.ts
    packages/ecson/src/schemas/transform.ts
    packages/ecson/src/schemas/component-instance.ts
    packages/ecson/src/schemas/entity.ts
    packages/ecson/src/schemas/asset.ts
    packages/ecson/src/schemas/wiring.ts
    packages/ecson/src/schemas/environment.ts
    packages/ecson/src/schemas/game-settings.ts
    packages/ecson/src/schemas/scene-document.ts
    packages/ecson/src/schemas/engine-tuning.ts
    packages/ecson/src/schemas/index.ts
    packages/ecson/src/index.ts
    packages/ecson/__tests__/schemas.test.ts
  </files>
  <action>
    Build ECSON schemas bottom-up using Zod v4 (via `zod@3.25+` dual-publish). Every type is defined as a Zod schema first, with TypeScript type derived via `z.infer<>`. NEVER write a separate interface.

    **Schema hierarchy (build in this order):**

    1. **Vec3Schema**: `{ x: number, y: number, z: number }` with defaults `{ x: 0, y: 0, z: 0 }`.

    2. **QuaternionSchema**: `{ x: number, y: number, z: number, w: number }` with default identity `{ x: 0, y: 0, z: 0, w: 1 }`.

    3. **TransformSchema**: `{ position: Vec3, rotation: Quaternion, scale: Vec3 }` with scale default `{ x: 1, y: 1, z: 1 }`.

    4. **EngineTuningSchema**: `z.record(z.string(), z.record(z.string(), z.unknown()))`. The outer key is engine name (e.g., `playcanvas`, `babylon`). The inner record holds arbitrary engine-specific properties. Per user decision: tuning can ADD engine-exclusive properties and OVERRIDE portable values. Place at both entity and component levels.

    5. **ComponentInstanceSchema**: `{ type: string, properties: Record<string, unknown>, tuning: EngineTuning (optional) }`. The `type` field is the component registry key (e.g., `"Light"`, `"MeshRenderer"`). Properties are validated dynamically against the component registry in Phase 1 Plan 5 -- for now, use `z.record(z.string(), z.unknown())`.

    6. **EntitySchema**: `{ id: string, name: string, parentId: string | null, children: string[] (ordered child IDs), components: ComponentInstance[], tags: string[], transform: Transform, visible: boolean (default true), locked: boolean (default false), tuning: EngineTuning (optional) }`. Entities are stored in a flat `Record<string, Entity>` map in the SceneDocument, with `parentId` references for hierarchy. `children` array preserves sibling order.

    7. **AssetEntrySchema**: `{ id: string, type: enum('mesh', 'texture', 'material', 'audio', 'animation', 'prefab', 'other'), name: string, uri: string (optional, for external refs), data: unknown (optional, for inline data), metadata: Record<string, unknown> }`.

    8. **EventWireSchema**: `{ id: string, sourceEntityId: string, sourceEvent: string, targetEntityId: string, targetAction: string, parameters: Record<string, unknown> (optional) }`. Represents a WHEN-DO event connection between entities.

    9. **EnvironmentSettingsSchema**: `{ skybox: { type: enum('color', 'image', 'hdri'), color: string (optional), uri: string (optional) }, fog: { enabled: boolean, type: enum('linear', 'exponential', 'exponential2'), color: string, near: number, far: number, density: number }, ambientLight: { color: string, intensity: number }, gravity: Vec3 (default { x: 0, y: -9.81, z: 0 }) }`. All fields with sensible defaults.

    10. **GameSettingsSchema**: `{ maxPlayers: number (default 8), roundDuration: number (default 120, seconds), respawnEnabled: boolean (default true), respawnDelay: number (default 3, seconds) }`. Optional in SceneDocument.

    11. **SceneDocumentSchema**: `{ id: string, name: string, schemaVersion: number (int, min 1), entities: Record<string, Entity>, rootEntityId: string, assets: Record<string, AssetEntry>, wiring: EventWire[], environment: EnvironmentSettings, gameSettings: GameSettings (optional), metadata: Record<string, unknown> }`.

    12. **Export** `CURRENT_SCHEMA_VERSION = 1` constant.

    13. **schemas/index.ts**: Barrel export of all schemas and their inferred types.

    14. **Update packages/ecson/src/index.ts**: Re-export everything from schemas/index.ts.

    **Tests** (`packages/ecson/__tests__/schemas.test.ts`):
    - Valid SceneDocument parses without error
    - Invalid SceneDocument (missing required fields) throws ZodError
    - Default values are applied correctly (Transform defaults, Environment defaults)
    - Engine tuning schema accepts arbitrary per-engine properties
    - Type inference works (compile-time check -- assert type assignments)
    - Empty entities record is valid
    - Entity with no components is valid
    - Entity with multiple components is valid
    - AssetEntry with uri and without uri both valid
    - EventWire validates source/target fields
  </action>
  <verify>
    `pnpm --filter @riff3d/ecson test` passes with all schema tests green.
    `pnpm --filter @riff3d/ecson typecheck` passes.
    All types are exported and accessible: `import { SceneDocument, Entity, Transform } from '@riff3d/ecson'`.
  </verify>
  <done>
    All ECSON core schemas are implemented as Zod validators. TypeScript types are derived via `z.infer<>`. The SceneDocument schema represents the full project file format with entities, assets, wiring, environment, game settings, and engine tuning. Tests validate parsing, defaults, and error cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ID generation, migration infrastructure, and helper utilities</name>
  <files>
    packages/ecson/src/ids.ts
    packages/ecson/src/migrations/migrate.ts
    packages/ecson/src/migrations/versions/.gitkeep
    packages/ecson/src/helpers.ts
    packages/ecson/src/index.ts
    packages/ecson/__tests__/ids.test.ts
    packages/ecson/__tests__/migrations.test.ts
  </files>
  <action>
    1. **ID Generation** (`packages/ecson/src/ids.ts`):
       - `generateEntityId()`: 16-char URL-safe alphanumeric using nanoid `customAlphabet('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 16)`.
       - `generateOpId()`: 21-char default nanoid (maximum collision resistance for operation logs).
       - `generateAssetId()`: Prefixed `ast_` + 12-char alphanumeric for readability.
       - `generateWireId()`: Prefixed `wir_` + 12-char alphanumeric.
       - All functions are synchronous and deterministic given the same random source.

    2. **Migration Infrastructure** (`packages/ecson/src/migrations/migrate.ts`):
       - Define `Migration` type: `{ version: number; description: string; up: (doc: unknown) => unknown }`.
       - Define `migrations` array (empty for v1 -- no migrations needed yet).
       - Implement `migrateDocument(doc: unknown): SceneDocument`:
         - Extract `schemaVersion` from doc.
         - Apply each migration where `doc.schemaVersion < migration.version` in order.
         - After each migration, update `schemaVersion` and log a warning: `console.warn(\`Migrated ECSON document from v${prev} to v${migration.version}\`)`.
         - Final `SceneDocumentSchema.parse(current)` to validate the result.
       - Export `CURRENT_SCHEMA_VERSION` from this module as well (re-export from schemas).

    3. **Helper Utilities** (`packages/ecson/src/helpers.ts`):
       - `createEmptyDocument(name?: string): SceneDocument` -- creates a valid empty document with a root entity, no assets, no wiring, default environment, schema version 1. Uses `generateEntityId()` for the root entity ID and document ID.
       - `createEntity(name: string, parentId?: string | null): Entity` -- creates a valid entity with generated ID, empty components, default transform.

    4. **Update barrel** (`packages/ecson/src/index.ts`): Export IDs, migrations, helpers, and all schemas.

    **Tests:**
    - `ids.test.ts`:
      - Entity IDs are 16 chars, alphanumeric only
      - Op IDs are 21 chars
      - Asset IDs start with `ast_`
      - Wire IDs start with `wir_`
      - 1000 generated IDs have zero collisions

    - `migrations.test.ts`:
      - Document at current version passes through unchanged
      - Document at version 0 (hypothetical) would fail without migration
      - `migrateDocument` returns a valid SceneDocument per Zod
      - `createEmptyDocument()` produces a valid SceneDocument
      - `createEntity()` produces a valid Entity with generated ID
  </action>
  <verify>
    `pnpm --filter @riff3d/ecson test` passes with all tests green (schemas + ids + migrations).
    `pnpm --filter @riff3d/ecson typecheck` passes.
    `pnpm turbo typecheck lint test` passes for the full monorepo.
  </verify>
  <done>
    The `@riff3d/ecson` package is complete with: all ECSON Zod schemas, nanoid-based ID generators (entity, op, asset, wire), forward migration infrastructure, and helper utilities for creating empty documents and entities. All types derived from Zod. 100% of package tests pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @riff3d/ecson test` -- all tests pass
- `pnpm --filter @riff3d/ecson typecheck` -- no type errors
- `pnpm turbo typecheck lint test` -- full monorepo passes
- Import `{ SceneDocument, Entity, Transform, createEmptyDocument, generateEntityId }` from `@riff3d/ecson` works in downstream packages
</verification>

<success_criteria>
The @riff3d/ecson package fully defines the ECSON project file format as Zod schemas. Any downstream package can import types and validators. The migration infrastructure is in place for future schema evolution. ID generation produces globally unique, stable identifiers.
</success_criteria>

<output>
After completion, create `.planning/phases/01-contracts-testing-spine/01-02-SUMMARY.md`
</output>
