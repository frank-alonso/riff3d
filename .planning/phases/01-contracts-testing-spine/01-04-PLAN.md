---
phase: 01-contracts-testing-spine
plan: 04
type: tdd
wave: 3
depends_on: ["01-02"]
files_modified:
  - packages/canonical-ir/src/types/canonical-scene.ts
  - packages/canonical-ir/src/types/canonical-node.ts
  - packages/canonical-ir/src/types/canonical-component.ts
  - packages/canonical-ir/src/types/canonical-asset.ts
  - packages/canonical-ir/src/types/canonical-wire.ts
  - packages/canonical-ir/src/types/canonical-environment.ts
  - packages/canonical-ir/src/types/index.ts
  - packages/canonical-ir/src/portable-subset.ts
  - packages/canonical-ir/src/compiler.ts
  - packages/canonical-ir/src/decompiler.ts
  - packages/canonical-ir/src/index.ts
  - packages/canonical-ir/__tests__/types.test.ts
  - packages/canonical-ir/__tests__/compiler.test.ts
  - packages/canonical-ir/__tests__/decompiler.test.ts
  - packages/canonical-ir/__tests__/round-trip.test.ts
autonomous: true
requirements:
  - CORE-05
  - CORE-06
  - CORE-07
  - PORT-02

must_haves:
  truths:
    - "Canonical IR is defined as Zod schemas -- minimal, normalized, explicit, no editor sugar"
    - "The compiler transforms any valid ECSON SceneDocument into a valid CanonicalScene"
    - "The decompiler transforms a CanonicalScene back into a valid ECSON SceneDocument"
    - "Round-trip (ECSON -> IR -> ECSON) preserves the portable subset identically"
    - "The portable subset v0 covers: scene graph, transforms, parenting, mesh refs, baseline PBR materials, lights, cameras, basic animation, events/triggers"
    - "IR nodes are stored as a topologically sorted flat array with an index map for O(1) lookup"
    - "Engine tuning sections are preserved through compilation but explicitly separated from portable data"
  artifacts:
    - path: "packages/canonical-ir/src/types/canonical-scene.ts"
      provides: "Root Canonical IR scene type"
      contains: "CanonicalSceneSchema"
    - path: "packages/canonical-ir/src/portable-subset.ts"
      provides: "Portable subset v0 definition -- which fields/components are guaranteed portable"
      exports: ["PORTABLE_COMPONENT_TYPES", "isPortableProperty"]
    - path: "packages/canonical-ir/src/compiler.ts"
      provides: "ECSON -> Canonical IR compiler"
      exports: ["compile"]
    - path: "packages/canonical-ir/src/decompiler.ts"
      provides: "Canonical IR -> ECSON decompiler"
      exports: ["decompile"]
  key_links:
    - from: "packages/canonical-ir/src/compiler.ts"
      to: "packages/ecson/src/schemas/scene-document.ts"
      via: "imports SceneDocument type as input"
      pattern: "import.*SceneDocument.*@riff3d/ecson"
    - from: "packages/canonical-ir/src/compiler.ts"
      to: "packages/canonical-ir/src/types/canonical-scene.ts"
      via: "produces CanonicalScene as output"
      pattern: "CanonicalScene"
    - from: "packages/canonical-ir/src/decompiler.ts"
      to: "packages/ecson/src/schemas/scene-document.ts"
      via: "produces SceneDocument as output"
      pattern: "SceneDocument"
    - from: "packages/canonical-ir/src/compiler.ts"
      to: "packages/canonical-ir/src/portable-subset.ts"
      via: "uses portable subset definition to categorize properties"
      pattern: "PORTABLE_COMPONENT_TYPES"
---

<objective>
Define the Canonical IR spec as Zod schemas, implement the ECSON-to-IR compiler and IR-to-ECSON decompiler, and define the portable subset v0. Prove round-trip fidelity for the portable subset.

Purpose: Canonical IR is the normalized, portable representation that adapters consume. The compiler/decompiler pair enables the round-trip guarantee that is central to the portability model. The portable subset v0 defines exactly what is guaranteed to work across all engines.

Output: The `@riff3d/canonical-ir` package exports IR types, `compile()` and `decompile()` functions, the portable subset definition, and round-trip tests proving ECSON -> IR -> ECSON identity for portable data.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-contracts-testing-spine/01-RESEARCH.md
@.planning/phases/01-contracts-testing-spine/01-02-SUMMARY.md

Prototype reference:
@/home/frank/riff3d-prototype/.planning/rebuild-research/01-canonical-layer-research.md
@/home/frank/riff3d-prototype/.planning/rebuild-research/FOUNDATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Canonical IR types, portable subset v0, and write test contracts</name>
  <files>
    packages/canonical-ir/src/types/canonical-scene.ts
    packages/canonical-ir/src/types/canonical-node.ts
    packages/canonical-ir/src/types/canonical-component.ts
    packages/canonical-ir/src/types/canonical-asset.ts
    packages/canonical-ir/src/types/canonical-wire.ts
    packages/canonical-ir/src/types/canonical-environment.ts
    packages/canonical-ir/src/types/index.ts
    packages/canonical-ir/src/portable-subset.ts
    packages/canonical-ir/src/index.ts
    packages/canonical-ir/__tests__/types.test.ts
  </files>
  <action>
    **TDD: Write type validation tests FIRST, then implement schemas.**

    **RED phase -- tests:**
    - CanonicalScene validates with required fields
    - CanonicalNode requires explicit transform (no implicit defaults)
    - CanonicalComponent has no editor sugar fields
    - Portable subset includes expected component types
    - Non-portable components are flagged correctly

    **GREEN phase -- implement IR schemas:**

    The key difference between ECSON and Canonical IR: IR is **minimal, normalized, explicit**. No defaults, no editor sugar, no optional fields that imply defaults.

    1. **CanonicalNodeSchema**: `{ id: string, name: string, parentId: string|null, childIds: string[], transform: { position: Vec3, rotation: Quaternion, scale: Vec3 } (all fields required, no defaults), components: CanonicalComponent[], visible: boolean, tuning: Record<string, Record<string, unknown>> (optional -- engine-specific data preserved but separated) }`.

    2. **CanonicalComponentSchema**: `{ type: string, properties: Record<string, unknown> }`. No editor hints, no metadata -- pure data. The component type is the registry key.

    3. **CanonicalAssetSchema**: `{ id: string, type: string, name: string, uri: string|null, data: unknown|null }`. Normalized from ECSON AssetEntry.

    4. **CanonicalWireSchema**: `{ id: string, sourceNodeId: string, sourceEvent: string, targetNodeId: string, targetAction: string, parameters: Record<string, unknown> }`. All fields required (no optionals in IR).

    5. **CanonicalEnvironmentSchema**: Flattened, explicit version of ECSON EnvironmentSettings. All values baked in (no defaults assumed).

    6. **CanonicalSceneSchema**: `{ id: string, name: string, sourceSchemaVersion: number, nodes: CanonicalNode[] (topologically sorted -- parents before children), nodeIndex: Record<string, number> (id -> array index for O(1) lookup), rootNodeId: string, assets: CanonicalAsset[], wires: CanonicalWire[], environment: CanonicalEnvironment, gameSettings: Record<string, unknown>|null }`.

    7. **portable-subset.ts**:
       - `PORTABLE_COMPONENT_TYPES`: Set of component type strings guaranteed portable: `MeshRenderer`, `Light`, `Camera`, `RigidBody`, `Collider`, `AudioSource`, `AudioListener`, `Animation`, `Material`.
       - `PORTABLE_LIGHT_TYPES`: `directional`, `point`, `spot` (not `hemisphere` -- engine-specific).
       - `PORTABLE_CAMERA_TYPES`: `perspective`, `orthographic`.
       - `PORTABLE_MATERIAL_PROPERTIES`: baseColor, metallic, roughness, emissive, emissiveIntensity, opacity, alphaMode, alphaCutoff, doubleSided, texture slots (baseColorMap, normalMap, metallicRoughnessMap, emissiveMap, occlusionMap).
       - `isPortableComponent(type: string): boolean` -- checks if component type is in the portable set.
       - `isPortableProperty(componentType: string, propertyPath: string): boolean` -- checks if a specific property is portable for the given component type.
       - Document the portable subset v0 boundary clearly in code comments.

    8. **types/index.ts**: Barrel export all IR types.
    9. **Update src/index.ts**: Export types and portable-subset.
  </action>
  <verify>
    `pnpm --filter @riff3d/canonical-ir test` passes type validation tests.
    `pnpm --filter @riff3d/canonical-ir typecheck` passes.
  </verify>
  <done>
    Canonical IR types are defined as Zod schemas. The portable subset v0 is formally defined (component types, property lists). IR is minimal, normalized, and explicit -- no editor sugar, no implicit defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement compiler (ECSON->IR), decompiler (IR->ECSON), and prove round-trip</name>
  <files>
    packages/canonical-ir/src/compiler.ts
    packages/canonical-ir/src/decompiler.ts
    packages/canonical-ir/src/index.ts
    packages/canonical-ir/__tests__/compiler.test.ts
    packages/canonical-ir/__tests__/decompiler.test.ts
    packages/canonical-ir/__tests__/round-trip.test.ts
  </files>
  <action>
    **TDD: Write compiler/decompiler/round-trip tests FIRST.**

    **RED phase -- tests:**

    `compiler.test.ts`:
    - Compiles empty document (root entity only) to valid CanonicalScene
    - Compiles document with nested entities (parent-child hierarchy) into topologically sorted nodes array
    - Compiles entity with components into CanonicalNodes with CanonicalComponents
    - Compiles assets into CanonicalAssets
    - Compiles event wires into CanonicalWires
    - Compiles environment settings with all defaults baked in
    - Preserves engine tuning sections on nodes and components
    - nodeIndex provides correct O(1) lookup for all nodes
    - Rejects invalid ECSON (Zod parse failure)

    `decompiler.test.ts`:
    - Decompiles CanonicalScene back to valid SceneDocument
    - Restores entity hierarchy from sorted node array
    - Restores components on entities
    - Restores assets and wiring
    - Restores environment settings

    `round-trip.test.ts`:
    - ECSON -> compile -> decompile -> compare with original
    - For portable subset fields: exact equality
    - For non-portable fields: preserved if present (engine tuning)
    - Test with: empty document, single entity, nested hierarchy, entity with multiple components, entity with engine tuning

    **GREEN phase -- implement:**

    1. **compiler.ts** -- `compile(doc: SceneDocument): CanonicalScene`:
       - Validate input with `SceneDocumentSchema.parse(doc)`.
       - Build node array with topological sort: start from root, BFS/DFS producing parents before children.
       - For each entity, create CanonicalNode:
         - Bake all transform defaults (position/rotation/scale must be fully explicit).
         - Convert ComponentInstance[] to CanonicalComponent[] (strip editor hints, keep properties).
         - Preserve tuning sections.
       - Build nodeIndex: `{ [nodeId]: arrayIndex }`.
       - Convert assets: AssetEntry -> CanonicalAsset (normalize, ensure all fields present).
       - Convert wires: EventWire -> CanonicalWire (ensure all fields present).
       - Compile environment: bake all defaults into explicit values.
       - Return validated `CanonicalSceneSchema.parse(result)`.

    2. **decompiler.ts** -- `decompile(ir: CanonicalScene): SceneDocument`:
       - Validate input with `CanonicalSceneSchema.parse(ir)`.
       - Convert node array back to entity record: `Record<string, Entity>`.
       - Restore parentId/children relationships from node data.
       - Convert CanonicalComponent -> ComponentInstance.
       - Convert CanonicalAsset -> AssetEntry.
       - Convert CanonicalWire -> EventWire.
       - Restore environment settings.
       - Set schemaVersion to `CURRENT_SCHEMA_VERSION`.
       - Return validated `SceneDocumentSchema.parse(result)`.

    3. **Round-trip normalization**: The round-trip test should compare using a normalization function that sorts entity keys, sorts component arrays by type, and uses json-stable-stringify for comparison. This handles the fact that Record key ordering is not guaranteed. The PORTABLE SUBSET must be identical after round-trip. Non-portable data should be preserved but may have different ordering.

    4. **Update src/index.ts**: Export `compile`, `decompile`.

    Run all tests. They should pass.

    **REFACTOR**: Extract shared normalization utilities.
  </action>
  <verify>
    `pnpm --filter @riff3d/canonical-ir test` passes ALL tests (types + compiler + decompiler + round-trip).
    `pnpm --filter @riff3d/canonical-ir typecheck` passes.
    `pnpm turbo typecheck lint test` passes for full monorepo.
    Round-trip tests prove portable subset identity for at least 5 different document structures.
  </verify>
  <done>
    The Canonical IR compiler and decompiler are implemented and proven correct. ECSON -> IR -> ECSON round-trip preserves the portable subset identically. IR nodes are topologically sorted with O(1) index lookup. Engine tuning is preserved through compilation. The portable subset v0 boundary is enforced in code.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @riff3d/canonical-ir test` -- all tests pass
- `pnpm --filter @riff3d/canonical-ir typecheck` -- no type errors
- Round-trip tests cover: empty doc, single entity, nested hierarchy, components, assets, wiring, tuning
- Portable subset documented in code with explicit membership checks
- Full monorepo pipeline passes
</verification>

<success_criteria>
The @riff3d/canonical-ir package defines the IR spec, implements bidirectional compilation, and proves the portable subset round-trips identically. Adapters (Phase 2/4) can consume CanonicalScene to render scenes. The portable subset v0 boundary is clear and enforced.
</success_criteria>

<output>
After completion, create `.planning/phases/01-contracts-testing-spine/01-04-SUMMARY.md`
</output>
