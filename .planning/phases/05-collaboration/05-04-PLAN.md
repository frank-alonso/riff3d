---
phase: 05-collaboration
plan: 04
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - apps/editor/src/collaboration/lock-manager.ts
  - apps/editor/src/collaboration/hooks/use-entity-locks.ts
  - apps/editor/src/components/editor/hierarchy/tree-node.tsx
  - apps/editor/src/components/editor/inspector/inspector-panel.tsx
  - apps/editor/src/stores/slices/scene-slice.ts
  - packages/adapter-playcanvas/src/editor-tools/lock-renderer.ts
autonomous: true
requirements: ["COLLAB-03"]

must_haves:
  truths:
    - "A user can click a lock icon on an entity in the hierarchy to lock it for exclusive editing"
    - "Locking an entity also locks all its descendants in the hierarchy"
    - "Other users see a lock icon on locked entity rows and the lock holder's name"
    - "Other users cannot edit locked entities -- inspector opens in read-only mode with lock holder name displayed"
    - "Lock auto-releases when the user deselects the entity"
    - "Lock auto-releases when the user disconnects"
    - "Locked entities show a subtle color tint in the 3D viewport matching the lock holder's color"
  artifacts:
    - path: "apps/editor/src/collaboration/lock-manager.ts"
      provides: "Lock acquisition, release, hierarchical propagation, Awareness-based lock registry"
      exports: ["LockManager", "acquireLock", "releaseLock", "isEntityLocked"]
    - path: "apps/editor/src/collaboration/hooks/use-entity-locks.ts"
      provides: "Hook for querying lock state and managing locks"
      exports: ["useEntityLocks"]
    - path: "packages/adapter-playcanvas/src/editor-tools/lock-renderer.ts"
      provides: "Subtle color tint on locked entities in viewport"
      exports: ["LockRenderer"]
  key_links:
    - from: "lock-manager.ts"
      to: "y-protocols/awareness"
      via: "Lock state stored in Awareness (ephemeral, auto-clears on disconnect)"
      pattern: "awareness\\.setLocalStateField.*locks"
    - from: "inspector-panel.tsx"
      to: "use-entity-locks.ts"
      via: "Read-only gate based on lock status"
      pattern: "isLockedByOther.*readOnly"
    - from: "tree-node.tsx"
      to: "use-entity-locks.ts"
      via: "Lock icon and holder name display"
      pattern: "lockInfo.*holderName"
---

<objective>
Implement entity-level locking with hierarchical propagation: users can manually lock entities for exclusive editing, with visual indicators in both hierarchy and viewport, and read-only inspector for other users.

Purpose: Locking prevents destructive concurrent edits on the same entity and provides clear ownership signaling. This is critical for collaborative workflows where users may be working on adjacent scene regions.

Output: Lock manager, lock UI in hierarchy/inspector/viewport, auto-release on deselect/disconnect
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-collaboration/05-RESEARCH.md
@.planning/phases/05-collaboration/05-CONTEXT.md
@.planning/phases/05-collaboration/05-02-SUMMARY.md
@apps/editor/src/collaboration/awareness-state.ts
@apps/editor/src/collaboration/provider.tsx
@apps/editor/src/stores/slices/scene-slice.ts
@apps/editor/src/components/editor/hierarchy/tree-node.tsx
@apps/editor/src/components/editor/inspector/inspector-panel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lock manager with hierarchical propagation and Awareness-based registry</name>
  <files>
    apps/editor/src/collaboration/lock-manager.ts
    apps/editor/src/collaboration/hooks/use-entity-locks.ts
    apps/editor/src/stores/slices/scene-slice.ts
  </files>
  <action>
    Build the entity locking system using Yjs Awareness state (ephemeral, auto-clears on disconnect).

    **Lock manager (`lock-manager.ts`):**
    - Locks stored in each user's Awareness state as `locks: string[]` (array of entity IDs this user has locked)
    - Per locked decision: locks are Awareness-based (NOT Y.Doc), so they auto-clear on disconnect

    `acquireLock(entityId, ecsonDoc, awareness)`:
    - Check if entity (or any ancestor) is already locked by another user -- scan all Awareness states
    - If locked by someone else: return `{ success: false, holder: { name, color } }`
    - Gather all descendants of entityId by walking the ECSON entity tree (parentId chain)
    - Add entityId + all descendant IDs to the local user's `locks` array in Awareness
    - Return `{ success: true }`

    `releaseLock(entityId, awareness)`:
    - Remove entityId and all its descendants from the local user's `locks` array in Awareness
    - Called when: user deselects the entity, user explicitly unlocks, or on cleanup

    `isEntityLocked(entityId, awareness, localClientId)`:
    - Scan all Awareness states for any user who has entityId in their locks
    - Return `{ locked: boolean, lockedByMe: boolean, holder?: { name, color } }`
    - Check both exact match and ancestor match (if parent is locked, child is implicitly locked)

    `getLockedEntities(awareness, localClientId)`:
    - Return a Map<entityId, { lockedByMe: boolean, holder: { name, color } }> for all currently locked entities across all users

    **Selection-based auto-release:**
    Per locked decision: lock auto-releases when user deselects the entity.
    - In scene-slice.ts, modify `setSelection`:
      - When selection changes and collab is active, check if previously selected entities had locks held by this user
      - For any previously-selected entities that are no longer selected AND were locked by this user, call `releaseLock`
      - This creates a natural flow: select entity -> lock it -> edit -> select different entity -> lock auto-releases

    **Lock guard on dispatchOp:**
    - In scene-slice.ts `dispatchOp`, before applying the op, check if the target entity is locked by another user
    - If locked by someone else: throw an error or silently reject (the inspector should already be read-only, but this is a safety net)
    - Extract entity ID from the PatchOp payload (entityId field present on SetProperty, SetTransform, Reparent, AddComponent, RemoveComponent, DeleteEntity)

    **Hook (`use-entity-locks.ts`):**
    - `useEntityLocks()`: Returns current lock state map and lock/unlock functions
    - `lockEntity(entityId)`: Call acquireLock, show toast on failure ("Entity locked by Alice")
    - `unlockEntity(entityId)`: Call releaseLock
    - `getLockInfo(entityId)`: Return lock status for a specific entity
    - Re-renders on Awareness change events

    Run `pnpm typecheck` and `pnpm test`.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm test` passes
    - Lock manager correctly computes descendant set from ECSON entity tree
    - Lock manager correctly prevents double-locking by different users
    - dispatchOp rejects ops on entities locked by others
  </verify>
  <done>
    Lock manager handles acquisition with hierarchical propagation, release on deselect, and Awareness-based storage for automatic disconnect cleanup. dispatchOp guards against editing locked entities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Lock UI in hierarchy panel, read-only inspector, and viewport lock tint</name>
  <files>
    apps/editor/src/components/editor/hierarchy/tree-node.tsx
    apps/editor/src/components/editor/inspector/inspector-panel.tsx
    packages/adapter-playcanvas/src/editor-tools/lock-renderer.ts
    packages/adapter-playcanvas/src/editor-tools/index.ts
    apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  </files>
  <action>
    Build the visual indicators for entity locking.

    **Hierarchy lock icon (`tree-node.tsx` modification):**
    Per locked decision: lock icon on entity row + hierarchy icon + both displayed together.
    - Import `useEntityLocks` hook
    - For each entity row, check lock status via `getLockInfo(entityId)`
    - If locked by another user: show a small lock icon (lucide-react Lock icon, 12px) in the user's color, with a tooltip showing "Locked by Alice"
    - If locked by self: show an unlock icon (lucide-react Unlock icon, 12px) in own color
    - Add a lock button (click to acquire lock) that appears on hover:
      - Only visible in collaborative mode
      - Click calls `lockEntity(entityId)`
      - Disabled if entity is already locked by someone else
    - Descendant entities of a locked parent show a dimmed lock icon (indicating inherited lock)

    **Read-only inspector for locked entities (`inspector-panel.tsx` modification):**
    Per locked decision: inspector opens in read-only mode, values visible but not editable, lock holder name displayed.
    - When an entity is selected that is locked by another user:
      - Show a banner at the top of the inspector: "Locked by Alice" with their color accent
      - All property inputs become disabled/read-only (add `disabled` or `readOnly` prop)
      - Number sliders, text inputs, color pickers, dropdowns -- all disabled
      - Values are still visible so the user can see the current state
    - When locked by self: normal editing (lock indicates exclusive access, not read-only for self)

    **Viewport lock tint (`lock-renderer.ts`):**
    Per locked decision: subtle color tint/outline in 3D viewport matching lock holder's user color.
    - Create `LockRenderer` class (similar pattern to PresenceRenderer)
    - Takes `pc.Application` reference
    - `update(lockedEntities: Map<entityId, { color: string }>)`:
      - For each locked entity visible in the scene:
        - Find the corresponding PlayCanvas entity by traversing the scene graph (match by entity name or a mapping from IR node IDs to PC entities)
        - Apply a subtle emissive tint to the entity's materials in the lock holder's color (similar to selection highlight but more subtle, e.g., 0.1 intensity vs 0.3 for selection)
        - Alternative: draw a colored wireframe bounding box around the entity using `app.drawLines()`
      - The wireframe bounding box approach is simpler and avoids modifying materials:
        - Get entity AABB (axis-aligned bounding box)
        - Draw 12 lines for the box edges in the holder's color with reduced alpha
    - `dispose()`: clean up any created resources
    - Wire into viewport-canvas.tsx alongside PresenceRenderer

    Run `pnpm typecheck` and `pnpm test`.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm test` passes
    - Tab A locks an entity: Tab B sees lock icon on that entity row, lock icon on descendants
    - Tab B selects locked entity: inspector shows "Locked by [name]" banner, all inputs disabled
    - Tab B attempts to edit locked entity: edit is rejected/blocked
    - Locked entity shows colored wireframe bounding box in viewport
    - Tab A deselects entity: lock auto-releases, Tab B can now edit
    - Tab A disconnects: lock auto-releases (Awareness cleanup)
  </verify>
  <done>
    Lock icons in hierarchy, read-only inspector for locked entities, and viewport lock tint all functional. Locking is manual, hierarchical, and auto-releases on deselect and disconnect.
  </done>
</task>

</tasks>

<verification>
- Entity locking works end-to-end: acquire, propagate to descendants, display in UI, prevent edits, auto-release
- Lock state is ephemeral (Awareness-based), auto-clears on disconnect
- Read-only inspector shows lock holder information
- Viewport shows subtle lock indicator
</verification>

<success_criteria>
- COLLAB-03: Object-level locking with hierarchical lock propagation
- Manual lock via explicit button (not auto-lock on select)
- Locking parent locks descendants
- Read-only inspector for other users viewing locked entities
- Auto-release on deselect and disconnect
- Visual lock indicators in hierarchy (icon) and viewport (tint/wireframe)
</success_criteria>

<output>
After completion, create `.planning/phases/05-collaboration/05-04-SUMMARY.md`
</output>
