---
phase: 05-collaboration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - servers/collab/src/server.ts
  - servers/collab/src/auth.ts
  - servers/collab/src/persistence.ts
  - servers/collab/src/index.ts
  - servers/collab/package.json
  - servers/collab/tsconfig.json
  - apps/editor/src/collaboration/provider.tsx
  - apps/editor/src/collaboration/sync-bridge.ts
  - apps/editor/src/collaboration/awareness-state.ts
  - apps/editor/src/collaboration/presence-colors.ts
  - apps/editor/src/stores/slices/collab-slice.ts
  - apps/editor/src/stores/slices/scene-slice.ts
  - apps/editor/src/stores/editor-store.ts
  - apps/editor/src/hooks/use-auto-save.ts
  - apps/editor/src/components/editor/shell/editor-shell.tsx
  - apps/editor/package.json
  - pnpm-workspace.yaml
autonomous: true
requirements: ["COLLAB-01", "COLLAB-05"]

must_haves:
  truths:
    - "A local PatchOp dispatched on one client propagates to Y.Doc and appears on a second client connected to the same project"
    - "Concurrent edits on different properties of the same entity are both preserved (Yjs CRDT merge)"
    - "Each user has an independent undo stack -- undoing on one client does not undo another user's operations"
    - "The editor connects to the Hocuspocus server using Supabase JWT and syncs the Y.Doc"
    - "In collaborative mode, persistence flows through Hocuspocus (server-side save), not client-side auto-save"
  artifacts:
    - path: "servers/collab/src/server.ts"
      provides: "Hocuspocus server with auth and persistence hooks"
      exports: ["server"]
    - path: "apps/editor/src/collaboration/sync-bridge.ts"
      provides: "Bidirectional ECSON <-> Y.Doc sync with origin tagging"
      exports: ["syncEntityToYDoc", "observeRemoteChanges", "initializeYDoc"]
    - path: "apps/editor/src/collaboration/provider.tsx"
      provides: "React context for HocuspocusProvider, Y.Doc, Awareness"
      exports: ["CollaborationProvider", "useCollaboration"]
    - path: "apps/editor/src/stores/slices/collab-slice.ts"
      provides: "Collab state: connected, synced, userColor, collaborators list"
  key_links:
    - from: "scene-slice.ts dispatchOp"
      to: "sync-bridge.ts syncEntityToYDoc"
      via: "PatchOp -> ECSON mutation -> Y.Doc sync with ORIGIN_LOCAL tag"
      pattern: "syncEntityToYDoc.*ORIGIN_LOCAL"
    - from: "sync-bridge.ts observeRemoteChanges"
      to: "scene-slice.ts loadProject"
      via: "Y.Doc observer -> rebuild ECSON -> loadProject (origin=ORIGIN_REMOTE)"
      pattern: "observeRemoteChanges.*ORIGIN_REMOTE"
    - from: "provider.tsx"
      to: "servers/collab/src/server.ts"
      via: "HocuspocusProvider WebSocket connection with Supabase JWT token"
      pattern: "HocuspocusProvider.*token.*access_token"
---

<objective>
Build the collaboration infrastructure: Hocuspocus WebSocket server, ECSON<->Y.Doc bidirectional sync bridge, per-user Y.UndoManager, and collaborative save strategy.

Purpose: This is the core CRDT integration that enables real-time co-editing. After this plan, two browser tabs connected to the same project can see each other's edits propagated via Yjs, with independent undo stacks per user. All subsequent collaboration features (presence, locking, avatars) build on this foundation.

Output: Working Hocuspocus server, sync bridge, collaborative undo, Y.Doc-based persistence
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-collaboration/05-RESEARCH.md
@.planning/phases/05-collaboration/05-CONTEXT.md
@.planning/phases/05-collaboration/05-01-SUMMARY.md
@apps/editor/src/stores/slices/scene-slice.ts
@apps/editor/src/stores/editor-store.ts
@apps/editor/src/hooks/use-auto-save.ts
@apps/editor/src/components/editor/shell/editor-shell.tsx
@apps/editor/src/app/editor/[projectId]/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hocuspocus server with Supabase auth and persistence</name>
  <files>
    servers/collab/src/server.ts
    servers/collab/src/auth.ts
    servers/collab/src/persistence.ts
    servers/collab/src/index.ts
    servers/collab/package.json
    servers/collab/tsconfig.json
    pnpm-workspace.yaml
  </files>
  <action>
    Create the Hocuspocus collaboration server as a new package in `servers/collab/`.

    **Package setup:**
    - Create `servers/collab/package.json` with name `@riff3d/collab-server`, type module
    - Dependencies: `@hocuspocus/server@^3.4.4`, `@hocuspocus/extension-database@^3.4.4`, `@supabase/supabase-js`
    - Dev dependencies: `tsx` for running TypeScript directly
    - Scripts: `"dev": "tsx watch src/index.ts"`, `"start": "tsx src/index.ts"`
    - Create `servers/collab/tsconfig.json` extending the root tsconfig with strict mode
    - Add `servers/collab` to `pnpm-workspace.yaml` packages array

    **Server (`server.ts`):**
    - Create Hocuspocus Server on configurable port (env `COLLAB_PORT`, default 1234)
    - onAuthenticate hook: verify Supabase JWT using `supabase.auth.getUser(token)`, check project access via projects table query (owner or public project), return user info (id, name, color assigned from palette)
    - onDisconnect hook: log disconnection for debugging
    - CORS headers configured for the editor origin (env `EDITOR_ORIGIN`, default `http://localhost:3000`)

    **Auth (`auth.ts`):**
    - Export `createAuthHandler(supabase)` that returns the onAuthenticate callback
    - Use `SUPABASE_URL` and `SUPABASE_SERVICE_ROLE_KEY` env vars for the server-side Supabase client
    - Verify JWT, query project access, return user metadata

    **Persistence (`persistence.ts`):**
    - Use `@hocuspocus/extension-database` Database extension
    - `fetch`: Load Y.Doc binary state from `collab_documents` table by `project_id`. If no row exists, return null (first sync will initialize from client ECSON)
    - `store`: Upsert Y.Doc binary state to `collab_documents` table as base64-encoded column. Also update the `projects.ecson` column by decoding Y.Doc to ECSON JSON (so non-collab project loads still work)
    - Create a Supabase migration SQL for `collab_documents` table: `project_id TEXT PRIMARY KEY REFERENCES projects(id), ydoc_state TEXT NOT NULL, updated_at TIMESTAMPTZ DEFAULT NOW()`

    **Entry point (`index.ts`):**
    - Import server, start listening, log port

    Run `pnpm install` to install new dependencies.
  </action>
  <verify>
    - `pnpm install` succeeds with no resolution errors
    - `pnpm typecheck --filter @riff3d/collab-server` passes
    - Server starts with `cd servers/collab && pnpm dev` and logs listening port
    - Migration SQL is valid (parseable)
  </verify>
  <done>
    Hocuspocus server runs standalone with Supabase JWT auth and Y.Doc persistence to Postgres. Migration SQL ready for collab_documents table.
  </done>
</task>

<task type="auto">
  <name>Task 2: ECSON<->Y.Doc sync bridge, collaboration provider, per-user undo, and save transition</name>
  <files>
    apps/editor/src/collaboration/provider.tsx
    apps/editor/src/collaboration/sync-bridge.ts
    apps/editor/src/collaboration/awareness-state.ts
    apps/editor/src/collaboration/presence-colors.ts
    apps/editor/src/stores/slices/collab-slice.ts
    apps/editor/src/stores/slices/scene-slice.ts
    apps/editor/src/stores/editor-store.ts
    apps/editor/src/hooks/use-auto-save.ts
    apps/editor/src/components/editor/shell/editor-shell.tsx
    apps/editor/package.json
  </files>
  <action>
    Build the client-side collaboration layer.

    **Dependencies:**
    - Add to apps/editor/package.json: `@hocuspocus/provider@^3.4.4`, `yjs@^13.6`, `y-protocols@^1.0`

    **Awareness state types (`awareness-state.ts`):**
    ```typescript
    interface PresenceState {
      user: { id: string; name: string; color: string };
      selection: string[];
      camera: { position: {x,y,z}; rotation: {x,y,z,w}; fov: number };
      mode: 'editor' | 'avatar';
      locks: string[];
    }
    ```

    **Presence colors (`presence-colors.ts`):**
    - Export the 12-color palette from research (PRESENCE_PALETTE array)
    - Export `assignUserColor(userIndex: number): string` function
    - Colors must be visually distinct against dark editor background

    **Sync bridge (`sync-bridge.ts`):**
    This is the critical integration seam. Must prevent infinite feedback loops via origin tagging.

    - `ORIGIN_LOCAL` and `ORIGIN_REMOTE` constants
    - `initializeYDoc(yDoc, ecsonDoc)`: Populate Y.Doc from ECSON. Set `meta` Y.Map (id, name, schemaVersion, rootEntityId), `entities` Y.Map<entityId, Y.Map<prop, value>> with NESTED Y.Maps per entity (required for success criterion #2: concurrent property-level merge), `assets` Y.Map, `environment` Y.Map. Tag transaction with 'init' origin.
    - `syncToYDoc(yDoc, ecsonDoc, entityId?)`: After a local PatchOp, sync the changed entity (or full doc for structural ops like CreateEntity/DeleteEntity) to Y.Doc. Tag with ORIGIN_LOCAL. Use JSON.stringify comparison to avoid no-op writes.
    - `yDocToEcson(yDoc): SceneDocument`: Reconstruct a full ECSON document from Y.Doc state. Used when remote changes arrive.
    - `observeRemoteChanges(yDoc, onRemoteChange)`: Set up Y.Doc deep observer on entities/assets/environment maps. Skip events with ORIGIN_LOCAL origin. Call onRemoteChange with the new ECSON document.

    Per success criteria #2 (concurrent edits on different properties preserved): entities MUST be stored as nested Y.Maps (one Y.Map per entity, with keys for each top-level property: name, transform, components, parentId, etc.). This enables per-property LWW merge.

    **Collab slice (`collab-slice.ts`):**
    - State: `isCollaborating: boolean`, `isConnected: boolean`, `isSynced: boolean`, `isOffline: boolean`, `userColor: string`, `collaborators: Array<{id, name, color}>`, `collabError: string | null`
    - Actions: `setCollabState(partial)`, `setCollaborators(list)`

    **Collaboration provider (`provider.tsx`):**
    - React context wrapping children with HocuspocusProvider connection
    - On mount: get Supabase session token, create HocuspocusProvider with `url: NEXT_PUBLIC_COLLAB_URL`, `name: projectId`, `token: accessToken`
    - On `onSynced`: If Y.Doc is empty (first collaborative session), call `initializeYDoc(yDoc, ecsonDoc)`. If Y.Doc has content, call `yDocToEcson(yDoc)` and load into store via `loadProject()`.
    - On `onStatus`: Update collab-slice isConnected/isOffline
    - On `onAuthenticationFailed`: Set collabError
    - Set up `observeRemoteChanges` to rebuild ECSON from Y.Doc on remote changes
    - Create per-user Y.UndoManager with `captureTimeout: 0` and `trackedOrigins: new Set([clientId])` -- this replaces the PatchOps-based undo in collaborative mode
    - Expose via context: provider, yDoc, awareness, undoManager, connected, synced

    **Scene slice modifications (`scene-slice.ts`):**
    - After `dispatchOp` applies the PatchOp and recompiles IR, check if collaboration is active. If so, call `syncToYDoc()` to propagate to Y.Doc. The sync bridge reference can be stored in the collab slice or passed via a callback setter.
    - Add a `dispatchOpCollab` alternative path or a callback hook (`onAfterDispatch`) that the collaboration provider registers to sync changes.
    - For collaborative undo: when collab is active, undo/redo should delegate to Y.UndoManager instead of the PatchOps inverse stack. Add a `collabUndoManager` field that the provider sets.

    **Save strategy transition (`use-auto-save.ts`):**
    - Check collab-slice `isCollaborating` state
    - When collaborating: SKIP client-side auto-save (Hocuspocus server handles persistence via the Database extension). Only manual Ctrl+S should trigger a save (as a safety net).
    - When NOT collaborating: existing auto-save behavior unchanged

    **Offline behavior:**
    - Per locked decision: when connection is lost, set `isOffline: true` in collab slice
    - Editor goes read-only via `setReadOnly(true)` when offline
    - When reconnected, re-enable editing via `setReadOnly(false)`
    - The offline banner UI will be built in plan 05-03, but the state management must be ready here

    **Editor shell wiring (`editor-shell.tsx`):**
    - Wrap the editor content with `<CollaborationProvider projectId={projectId}>` when the feature is available (check env var `NEXT_PUBLIC_COLLAB_URL`)
    - If `NEXT_PUBLIC_COLLAB_URL` is not set, skip collaboration (solo editing mode preserved)

    Run `pnpm install`, `pnpm typecheck`, `pnpm test`.
  </action>
  <verify>
    - `pnpm install` resolves all new dependencies
    - `pnpm typecheck` passes across all packages
    - `pnpm test` passes (existing tests should not break)
    - With collab server running: open two browser tabs to same project, edit in one tab, change appears in other tab within 2 seconds
    - Undo in one tab does not affect the other tab's edits
    - Concurrent edits on different properties of same entity are both preserved
  </verify>
  <done>
    Two clients connected via Hocuspocus see each other's edits in real-time. Per-user Y.UndoManager provides independent undo stacks. Persistence flows through Hocuspocus server. Offline state detection ready for UI in 05-03.
  </done>
</task>

</tasks>

<verification>
- Hocuspocus server starts and accepts WebSocket connections
- Two browser tabs sync edits via Y.Doc within 2 seconds
- Concurrent property-level edits on same entity preserved (nested Y.Map merge)
- Per-user undo only reverts own changes
- Server persists Y.Doc to collab_documents and syncs back to projects.ecson
- Solo editing (no collab URL) continues to work as before
</verification>

<success_criteria>
- COLLAB-01: Shared operation log backed by Yjs CRDTs -- Y.Doc syncs all ECSON changes
- COLLAB-05: Conflict resolution via Yjs LWW per property -- nested Y.Maps enable per-property merge
- Independent undo stacks via Y.UndoManager with captureTimeout:0 and trackedOrigins
- Save strategy transitions between solo (client auto-save) and collaborative (Hocuspocus persistence)
</success_criteria>

<output>
After completion, create `.planning/phases/05-collaboration/05-02-SUMMARY.md`
</output>
