---
phase: 05-collaboration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  - apps/editor/src/components/editor/viewport/viewport-provider.tsx
  - packages/adapter-playcanvas/src/adapter.ts
  - packages/adapter-babylon/src/adapter.ts
  - packages/canonical-ir/src/adapter-interface.ts
  - CLAUDE.md
  - .github/workflows/ci.yml
autonomous: true
requirements: []

must_haves:
  truths:
    - "Switching from PlayCanvas to Babylon (or vice versa) preserves the camera viewpoint -- position and rotation match within tolerance"
    - "Loading the editor with Babylon as the preferred engine and switching to PlayCanvas renders the scene correctly (no blank viewport)"
    - "Resizing the browser window (including opening/closing dev tools) does not cause the scene to stop rendering"
    - "ESLint no-restricted-imports rule prevents direct ECSON mutation from adapter/UI packages"
    - "CLAUDE.md exception contract lists all actual bypass points including engine preference setter"
  artifacts:
    - path: "apps/editor/src/components/editor/viewport/viewport-canvas.tsx"
      provides: "Robust canvas resize observer and camera state transfer"
    - path: "CLAUDE.md"
      provides: "Updated exception contract"
  key_links:
    - from: "viewport-canvas.tsx"
      to: "EngineAdapter.serializeCamera/restoreCamera"
      via: "Camera state transfer during engine switch"
      pattern: "serializeCamera.*restoreCamera"
---

<objective>
Fix carry-forward viewport bugs and mechanical enforcement items from Phase 4 review before adding collaboration complexity.

Purpose: The collaboration layer builds on the viewport and adapter lifecycle. Fixing stability bugs (camera sync, Babylon-first race, resize rendering) and adding mechanical enforcement (ESLint mutation boundary, CLAUDE.md alignment, CI artifacts) ensures a solid foundation for real-time multi-user editing.

Output: Stable viewport with engine switching, mechanical mutation boundary enforcement, updated CLAUDE.md
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-collaboration/05-RESEARCH.md
@.planning/phases/04-dual-adapter-validation/04-03-SUMMARY.md
@apps/editor/src/components/editor/viewport/viewport-canvas.tsx
@apps/editor/src/components/editor/viewport/viewport-provider.tsx
@packages/adapter-playcanvas/src/adapter.ts
@packages/adapter-babylon/src/adapter.ts
@packages/canonical-ir/src/adapter-interface.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix carry-forward viewport bugs CF-P4-05/06/07</name>
  <files>
    apps/editor/src/components/editor/viewport/viewport-canvas.tsx
    apps/editor/src/components/editor/viewport/viewport-provider.tsx
    packages/adapter-playcanvas/src/adapter.ts
    packages/adapter-babylon/src/adapter.ts
    packages/canonical-ir/src/adapter-interface.ts
  </files>
  <action>
    Fix three carry-forward viewport bugs:

    **CF-P4-05: Camera position/rotation not synced when swapping engines.**
    The EngineAdapter interface has serializeCamera/restoreCamera but the transfer may not be working correctly across engines. Debug the camera state serialization in both adapters:
    - Verify that PlayCanvasAdapter.serializeCamera() captures position AND rotation (not just position)
    - Verify that BabylonAdapter.restoreCamera() applies the serialized state correctly
    - Ensure the coordinate systems match (both use right-handed Y-up per IR convention)
    - Add explicit logging during engine switch to verify camera state transfer
    - Test: Switch engines, verify camera viewpoint is preserved (position and rotation within 0.01 tolerance)

    **CF-P4-06: Babylon-first load sometimes fails to render PlayCanvas on switch.**
    This is a race condition in adapter initialization. The issue is that when Babylon loads first, switching to PlayCanvas may fail because:
    - The previous adapter's dispose() may not complete before the new adapter's initialize() starts
    - The canvas may still be in use by the previous engine's rendering loop
    Fix: Add an explicit await on adapter.dispose() before starting the new adapter. Use the switch counter ref pattern (already in viewport-canvas.tsx) but ensure dispose is awaited. Add a small delay (requestAnimationFrame or 100ms timeout) between dispose and initialize to allow GPU context release.

    **CF-P4-07: Browser resize sometimes causes scene to stop rendering.**
    The canvas resize handling may be fragile. Fix:
    - Replace any window.addEventListener('resize') with a ResizeObserver on the canvas container div
    - The ResizeObserver callback should call adapter.resize(width, height) or equivalent
    - Both PlayCanvas and Babylon adapters need a resize method on the EngineAdapter interface
    - Add a `resize(width: number, height: number): void` method to the EngineAdapter interface
    - PlayCanvas: call app.resizeCanvas(width, height) in the resize handler
    - Babylon: call engine.resize() in the resize handler
    - Debounce the resize handler to avoid excessive redraws (use requestAnimationFrame batching)

    Run `pnpm typecheck` and `pnpm test` to verify no regressions.
  </action>
  <verify>
    - `pnpm typecheck` passes across all packages
    - `pnpm test` passes with zero failures
    - Manual test: switch PlayCanvas -> Babylon -> PlayCanvas, camera viewpoint preserved
    - Manual test: load with Babylon preferred, switch to PlayCanvas, scene renders
    - Manual test: resize browser window, scene continues rendering
  </verify>
  <done>
    Camera state transfers correctly between engines. Babylon-first race condition resolved. Resize observer keeps rendering stable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mechanical mutation enforcement and CLAUDE.md alignment (CF-P4-01/02/03)</name>
  <files>
    CLAUDE.md
    .github/workflows/ci.yml
    apps/editor/.eslintrc.cjs
    packages/adapter-playcanvas/.eslintrc.cjs
    packages/adapter-babylon/.eslintrc.cjs
  </files>
  <action>
    Address three carry-forward items from Phase 4 Codex review:

    **CF-P4-01: Mechanical mutation-boundary enforcement.**
    Add ESLint `no-restricted-imports` rules (or equivalent) to adapter packages and editor to prevent direct ECSON mutation bypassing PatchOps:
    - In adapter packages: disallow importing from `@riff3d/patchops` (adapters should never touch PatchOps directly per architecture rule)
    - In editor components (not stores/slices): consider restricting direct imports of `applyOp` -- only `dispatchOp` from the store should be used
    - Add a negative test that verifies the boundary: grep for `applyOp` imports in adapter packages and fail if found
    - If ESLint flat config is used, add the rules to the existing config files

    **CF-P4-02: Align CLAUDE.md exception contract.**
    Update the "Approved Architectural Exceptions" section in CLAUDE.md to include:
    - Exception 1: Add engine preference setter (`metadata.preferredEngine`) as an approved bypass point alongside loadProject() and playtest stop(). This was introduced in 04-03 and follows the same pattern.
    - Verify the exception text matches the actual code (check scene-slice.ts for loadProject, playtest-slice.ts for stop, engine-slice.ts for switchEngine).

    **CF-P4-03: CI artifact attachment.**
    Add a step to the CI workflow that uploads test results as GitHub Actions artifacts. This provides the evidence trail the Codex reviewer requested:
    - Upload vitest coverage/results if available
    - Upload any test output files
    - Use actions/upload-artifact@v4

    Run `pnpm lint` to verify the new ESLint rules don't have false positives.
  </action>
  <verify>
    - `pnpm lint` passes on all packages
    - `pnpm typecheck` passes
    - CLAUDE.md exception section lists all three bypass points (loadProject, playtest stop, engine preference)
    - Negative test script/grep confirms no `applyOp` imports in adapter packages
    - CI workflow includes artifact upload step
  </verify>
  <done>
    Mutation boundary is mechanically enforced via ESLint rules. CLAUDE.md exception contract is accurate. CI uploads test artifacts.
  </done>
</task>

</tasks>

<verification>
- All carry-forward items from Phase 4 review addressed: CF-P4-01, CF-P4-02, CF-P4-03, CF-P4-05, CF-P4-06, CF-P4-07
- Full monorepo test suite passes
- No lint errors or type errors
</verification>

<success_criteria>
- Engine switching preserves camera viewpoint
- Babylon-first load + switch to PlayCanvas renders correctly
- Browser resize does not break rendering
- ESLint enforces mutation boundary mechanically
- CLAUDE.md exception contract matches actual code
- CI workflow uploads test artifacts
</success_criteria>

<output>
After completion, create `.planning/phases/05-collaboration/05-01-SUMMARY.md`
</output>
