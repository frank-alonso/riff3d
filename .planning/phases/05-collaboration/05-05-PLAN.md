---
phase: 05-collaboration
plan: 05
type: execute
wave: 4
depends_on: ["05-03"]
files_modified:
  - apps/editor/src/collaboration/avatar-controller.ts
  - packages/adapter-playcanvas/src/editor-tools/avatar-renderer.ts
  - packages/adapter-playcanvas/src/editor-tools/index.ts
  - apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  - apps/editor/src/components/editor/shell/top-bar.tsx
  - apps/editor/src/collaboration/awareness-state.ts
autonomous: true
requirements: ["COLLAB-04"]

must_haves:
  truths:
    - "A user can toggle into avatar mode via an explicit toolbar button"
    - "In avatar mode, WASD moves a capsule avatar along the ground plane (FPS-style)"
    - "Other users see the capsule avatar with a floating name label moving in real-time"
    - "When in avatar mode, the user's presence indicator changes from frustum cone to capsule (in other users' viewports)"
    - "When not in avatar mode, the user's presence is shown as the standard frustum cone"
  artifacts:
    - path: "apps/editor/src/collaboration/avatar-controller.ts"
      provides: "WASD ground-plane movement controller for avatar mode"
      exports: ["AvatarController"]
    - path: "packages/adapter-playcanvas/src/editor-tools/avatar-renderer.ts"
      provides: "Capsule mesh + name label for remote avatars"
      exports: ["AvatarRenderer"]
  key_links:
    - from: "avatar-controller.ts"
      to: "awareness-state.ts"
      via: "Avatar position/rotation broadcast via Awareness"
      pattern: "awareness\\.setLocalStateField.*camera"
    - from: "avatar-renderer.ts"
      to: "presence-renderer.ts"
      via: "Replaces frustum cone when user mode is 'avatar'"
      pattern: "mode.*avatar.*capsule"
    - from: "top-bar.tsx"
      to: "awareness-state.ts"
      via: "Avatar mode toggle button sets mode in Awareness"
      pattern: "setLocalStateField.*mode.*avatar"
---

<objective>
Implement embodied avatar editing: users can toggle into avatar mode to walk around the 3D scene as a colored capsule while editing, and other users see their avatar moving in real-time.

Purpose: Avatar mode gives users a sense of physical presence in the 3D scene, enabling natural spatial communication about scene elements. It's the most immersive collaboration feature, turning the editor from a "shared document" into a "shared space."

Output: Avatar toggle button, WASD capsule movement, remote avatar rendering, presence mode switching
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-collaboration/05-RESEARCH.md
@.planning/phases/05-collaboration/05-CONTEXT.md
@.planning/phases/05-collaboration/05-03-SUMMARY.md
@apps/editor/src/collaboration/awareness-state.ts
@apps/editor/src/collaboration/hooks/use-awareness.ts
@packages/adapter-playcanvas/src/editor-tools/presence-renderer.ts
@packages/adapter-playcanvas/src/editor-tools/camera-controller.ts
@apps/editor/src/components/editor/shell/top-bar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Avatar mode toggle, WASD ground-plane controller, and Awareness broadcast</name>
  <files>
    apps/editor/src/collaboration/avatar-controller.ts
    apps/editor/src/components/editor/shell/top-bar.tsx
    apps/editor/src/collaboration/awareness-state.ts
    apps/editor/src/stores/slices/viewport-slice.ts
  </files>
  <action>
    Build the local avatar mode: toggle button, ground-plane WASD movement, and presence state broadcast.

    **Avatar mode in viewport-slice:**
    - Add `isAvatarMode: boolean` to ViewportSlice
    - Add `toggleAvatarMode()` action that flips the boolean
    - When entering avatar mode: disable the normal camera controller (orbit/pan/zoom/fly) and enable the avatar controller
    - When exiting avatar mode: restore normal camera controller

    **Avatar toggle button (`top-bar.tsx` modification):**
    Per locked decision: explicit toolbar toggle to switch between normal editor camera and embodied avatar mode.
    - Add a toggle button between the engine switcher and play controls (or near them)
    - Icon: User/UserCircle from lucide-react when not in avatar mode, a different icon (e.g., PersonStanding or Footprints) when in avatar mode
    - Button changes color/style when active (avatar mode on)
    - Only visible when collaborating (isCollaborating from collab-slice)
    - On toggle: update Awareness state `mode: 'editor' | 'avatar'` so other users see the change
    - Disabled during play mode (can't be in avatar mode while play-testing)

    **Avatar controller (`avatar-controller.ts`):**
    Per locked decision: WASD walk mode for FPS-style ground-plane movement.
    - Create `AvatarController` class
    - Constructor takes reference to PlayCanvas camera entity or a position/rotation state
    - WASD controls:
      - W: move forward along camera's look direction (projected onto XZ plane)
      - S: move backward
      - A: strafe left
      - D: strafe right
      - Mouse move: rotate camera yaw (horizontal look)
    - Ground-plane constraint:
      - Avatar Y position stays at ground level (Y=0 by default)
      - Future: raycast downward for terrain, but for now Y=0 + capsuleHalfHeight (0.9m for ~1.8m capsule)
    - Movement speed: 5 m/s walking speed (reasonable for editing walkthrough)
    - The camera follows the avatar position (first-person perspective from capsule head position, ~1.7m above ground)
    - Keyboard event handling: register on canvas element, prevent propagation to normal editor shortcuts
    - `update(dt)`: called per frame, moves avatar position, broadcasts to Awareness:
      ```
      awareness.setLocalStateField('camera', {
        position: { x, y, z },
        rotation: { x, y, z, w },  // Quaternion of camera look direction
        fov: camera.fov
      });
      ```
    - `enable()` / `disable()`: start/stop listening to keyboard events, show/hide pointer lock prompt
    - Optional: request pointer lock on canvas for smooth mouse look (with ESC to exit)

    **Awareness integration:**
    - When entering avatar mode: set `awareness.setLocalStateField('mode', 'avatar')`
    - When exiting: set `awareness.setLocalStateField('mode', 'editor')`
    - Camera position broadcasts happen at the same throttled rate as normal editor camera (100ms from 05-03)

    Run `pnpm typecheck` and `pnpm test`.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm test` passes
    - Avatar toggle button visible in top bar when collaborating
    - Clicking toggle switches to avatar mode, WASD moves along ground plane
    - Camera perspective changes to first-person at capsule head height
    - Awareness state shows mode: 'avatar' when active
    - Exiting avatar mode restores normal camera
  </verify>
  <done>
    Avatar mode toggle works, WASD controller moves along ground plane, camera broadcasts avatar position via Awareness.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remote avatar capsule rendering and presence mode switching</name>
  <files>
    packages/adapter-playcanvas/src/editor-tools/avatar-renderer.ts
    packages/adapter-playcanvas/src/editor-tools/presence-renderer.ts
    packages/adapter-playcanvas/src/editor-tools/index.ts
    apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  </files>
  <action>
    Build the remote avatar visualization: when a remote user is in avatar mode, render a colored capsule instead of a frustum cone.

    **Avatar renderer (`avatar-renderer.ts`):**
    Per locked decision: simple colored capsule with floating name label above.
    - Create `AvatarRenderer` class (similar pattern to PresenceRenderer)
    - Constructor takes `pc.Application`
    - Manages a pool of PlayCanvas capsule entities (one per remote avatar user)
    - For each remote user in 'avatar' mode:
      - Create or reuse a capsule entity:
        - Capsule mesh: `pc.Mesh.fromGeometry(app.graphicsDevice, new pc.CapsuleGeometry({...}))`
        - Dimensions: radius ~0.3m, height ~1.8m total (reasonable human-scale capsule)
        - Material: basic material with the user's color as diffuse, semi-transparent (alpha ~0.7)
      - Position capsule at the user's broadcasted position (Y = ground level, centered on capsule)
      - Rotate capsule to face the user's look direction (yaw only, capsule stays upright)
      - Floating name label: DOM overlay div (same approach as frustum cone name labels from 05-03)
        - Position above the capsule top (~2.0m above ground)
        - Same colored pill style as frustum cone labels
    - For users who LEAVE avatar mode: remove their capsule entity, they'll be rendered as frustum cones by PresenceRenderer
    - `update(remoteUsers)`: called each frame with current awareness state
    - `dispose()`: remove all capsule entities and DOM labels

    **Presence mode switching (`presence-renderer.ts` modification):**
    Per locked decision: when in avatar mode, capsule replaces frustum cone. When not in avatar mode, frustum cone + name label always visible.
    - Modify PresenceRenderer.update() to SKIP users whose `mode === 'avatar'` (they're rendered by AvatarRenderer instead)
    - This creates the mode-switching behavior: each user's 3D representation automatically changes based on their Awareness mode state

    **Viewport integration (`viewport-canvas.tsx` modification):**
    - Create AvatarRenderer alongside PresenceRenderer
    - On each frame update, pass the remote users list to both renderers
    - PresenceRenderer handles `mode === 'editor'` users (frustum cones)
    - AvatarRenderer handles `mode === 'avatar'` users (capsules)
    - Dispose both on adapter cleanup

    **Edge cases:**
    - User toggling avatar mode mid-session: frustum cone disappears, capsule appears (and vice versa) seamlessly
    - If PlayCanvas is not the active engine (user is on Babylon), avatar rendering is skipped (Babylon avatar deferred to Phase 5+)
    - If no remote users are in avatar mode, AvatarRenderer does nothing (no performance overhead)

    Run `pnpm typecheck` and `pnpm test`.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm test` passes
    - Tab A enters avatar mode: Tab B sees colored capsule with name label (not frustum cone)
    - Tab A moves with WASD: Tab B sees capsule moving in real-time
    - Tab A exits avatar mode: Tab B sees frustum cone again (capsule disappears)
    - Capsule is user-colored and semi-transparent
    - Name label floats above capsule and updates position each frame
  </verify>
  <done>
    Remote avatars render as colored capsules with name labels. Presence mode switching between frustum cone and capsule works seamlessly based on Awareness state.
  </done>
</task>

</tasks>

<verification>
- Avatar mode toggle works end-to-end
- WASD movement constrained to ground plane
- Remote users see capsule when user is in avatar mode, frustum cone otherwise
- Capsules are colored per user and have floating name labels
- Mode switching is seamless and responsive
</verification>

<success_criteria>
- COLLAB-04: Embodied avatar editing -- walk around 3D scene as avatar while editing, other users see avatar moving in real-time
- Explicit toolbar toggle (not always embodied) per locked decision
- WASD ground-plane movement per locked decision
- Capsule + name label per locked decision
- When not in avatar mode, others still see camera frustum cone per locked decision
</success_criteria>

<output>
After completion, create `.planning/phases/05-collaboration/05-05-SUMMARY.md`
</output>
