---
phase: 03-review-gate-foundation
plan: 05
type: execute
wave: 3
depends_on: [03-03]
files_modified:
  - packages/adapter-playcanvas/src/editor-tools/drag-preview.ts
  - packages/adapter-playcanvas/src/editor-tools/index.ts
  - apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  - apps/editor/src/components/editor/panels/asset-browser.tsx
  - packages/adapter-playcanvas/__tests__/drag-preview.test.ts
  - packages/conformance/__tests__/benchmarks.test.ts
  - packages/conformance/src/budgets.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "Dragging an asset from the asset browser into the viewport shows a translucent ghost entity following the cursor"
    - "Ghost entity position uses Y=0 ground plane raycasting (mathematical, no physics dependency)"
    - "Dropping the ghost creates a real entity via PatchOps (CreateEntity + AddComponent)"
    - "Ghost entity is cleaned up on drag leave or drop"
    - "Performance budgets define tiered thresholds (Excellent/Pass/Fail) for FPS, load time, memory, compilation, and PatchOp timing"
    - "Existing conformance benchmarks are updated with the tiered budget structure"
  artifacts:
    - path: "packages/adapter-playcanvas/src/editor-tools/drag-preview.ts"
      provides: "DragPreviewManager: ghost entity creation, ground plane raycasting, surface normal alignment"
    - path: "packages/conformance/src/budgets.ts"
      provides: "Tiered performance budget definitions (Excellent/Pass/Fail) for all metrics"
    - path: "packages/adapter-playcanvas/__tests__/drag-preview.test.ts"
      provides: "Tests for drag preview raycasting, ghost lifecycle, and cleanup"
  key_links:
    - from: "apps/editor/src/components/editor/viewport/viewport-canvas.tsx"
      to: "packages/adapter-playcanvas/src/editor-tools/drag-preview.ts"
      via: "DragPreviewManager initialization and DOM drag event wiring"
      pattern: "DragPreviewManager"
    - from: "packages/conformance/__tests__/benchmarks.test.ts"
      to: "packages/conformance/src/budgets.ts"
      via: "import tiered budget thresholds for benchmark assertions"
      pattern: "import.*budgets"
---

<objective>
Implement the drag-preview ghost feature and establish tiered performance budgets. The drag-preview creates a translucent entity that follows the cursor during asset drag operations, using mathematical ground plane raycasting (Y=0) since physics is not available until Phase 7. Performance budgets define Excellent/Pass/Fail thresholds for FPS, load time, memory, IR compilation, and PatchOp timing.

Purpose: The drag-preview ghost is a core editor UX feature that provides spatial awareness during asset placement. Tiered performance budgets formalize the success criteria for Phase 3 (criterion #4: "Performance budgets are met") with an Excellent tier that's forward-looking toward Phase 10 VR (72+ FPS).

Output: DragPreviewManager with ghost entity + raycasting, tiered budget definitions, updated conformance benchmarks.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-review-gate-foundation/03-RESEARCH.md
@.planning/phases/03-review-gate-foundation/03-03-SUMMARY.md
@packages/adapter-playcanvas/src/editor-tools/index.ts
@packages/adapter-playcanvas/src/adapter.ts
@packages/adapter-playcanvas/src/scene-builder.ts
@apps/editor/src/components/editor/viewport/viewport-canvas.tsx
@apps/editor/src/components/editor/panels/asset-browser.tsx
@packages/conformance/__tests__/benchmarks.test.ts
@packages/conformance/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DragPreviewManager with ghost entity and ground plane raycasting</name>
  <files>
    packages/adapter-playcanvas/src/editor-tools/drag-preview.ts
    packages/adapter-playcanvas/src/editor-tools/index.ts
    packages/adapter-playcanvas/__tests__/drag-preview.test.ts
    apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  </files>
  <action>
    **1. Create DragPreviewManager (`src/editor-tools/drag-preview.ts`):**

    Class that manages the drag-preview ghost entity lifecycle:

    ```typescript
    export interface DragPreviewConfig {
      app: pc.Application;
      camera: pc.Entity;
      canvas: HTMLCanvasElement;
      onDrop: (position: { x: number; y: number; z: number }, assetType: string) => void;
    }

    export class DragPreviewManager {
      private ghostEntity: pc.Entity | null = null;
      private ghostMaterial: pc.StandardMaterial | null = null;
      // ...

      constructor(config: DragPreviewConfig) { ... }

      /** Called on dragenter -- creates the translucent ghost entity */
      handleDragEnter(e: DragEvent): void { ... }

      /** Called on dragover -- updates ghost position via raycasting */
      handleDragOver(e: DragEvent): void { ... }

      /** Called on dragleave -- destroys ghost entity */
      handleDragLeave(e: DragEvent): void { ... }

      /** Called on drop -- invokes onDrop callback with final position, destroys ghost */
      handleDrop(e: DragEvent): void { ... }

      dispose(): void { ... }
    }
    ```

    **Ghost entity creation:**
    - Create a `pc.Entity` with a render component (box primitive by default, can be swapped per asset type)
    - Apply a `pc.StandardMaterial` with `opacity: 0.5` and `blendType: pc.BLEND_NORMAL`
    - Set emissive color to a light blue tint for visibility
    - Add to app.root as a temporary child (not in the ECSON entity map)

    **Ground plane raycasting (Y=0 mathematical intersection):**
    - Convert mouse screen coordinates to a 3D ray using `camera.camera.screenToWorld()`
    - Get near and far points from the camera projection
    - Calculate ray direction: `far - near`, normalize
    - Compute intersection with Y=0 plane: `t = -near.y / direction.y`
    - If `t > 0` (ray hits ground in front of camera), compute ground point: `near + direction * t`
    - Set ghost entity position to the ground point
    - If `t <= 0` (camera looking up / no ground intersection), place ghost at a fixed distance along the ray (e.g., 5 units from camera)

    **Surface normal alignment (deferred until Phase 7):**
    - When physics raycasting is available, the ghost can snap to surface normals. For now, ghost always aligns to world up (Y-axis). Add a TODO comment for Phase 7 integration.

    **Drop handling:**
    - Extract asset type from `e.dataTransfer` using the existing `ASSET_DRAG_MIME` constant
    - Call the `onDrop` callback with the ghost's final position and asset type
    - The viewport component will handle creating the real entity via PatchOps

    **2. Update editor-tools barrel export:**

    Add to `src/editor-tools/index.ts`:
    ```typescript
    export { DragPreviewManager, type DragPreviewConfig } from "./drag-preview";
    ```

    **3. Wire DragPreviewManager into viewport-canvas.tsx:**

    In the viewport component:
    - Create `DragPreviewManager` during adapter initialization, passing the app, camera, and canvas
    - Attach DOM drag event listeners to the canvas element: `dragenter`, `dragover`, `dragleave`, `drop`
    - The `onDrop` callback should:
      1. Determine the entity template based on asset type (box, sphere, light, etc.)
      2. Dispatch `CreateEntity` PatchOp at the drop position
      3. Dispatch `AddComponent` PatchOps for the appropriate components
    - Clean up `DragPreviewManager` on adapter dispose

    **4. Create unit tests (`__tests__/drag-preview.test.ts`):**

    Using the shared PlayCanvas mock factory:
    - `handleDragEnter` creates a ghost entity with opacity 0.5
    - `handleDragOver` updates ghost position using ground plane math
    - Ground plane math: given a camera at (0, 5, 10) looking at origin, screen center maps to (0, 0, 0)
    - `handleDragLeave` destroys ghost entity
    - `handleDrop` calls onDrop callback with correct position
    - `handleDrop` cleans up ghost entity
    - `dispose` removes all event listeners

    Test the raycasting math directly: given known camera position/direction, verify correct Y=0 intersection point.
  </action>
  <verify>
    Run `cd /home/frank/riff3d && pnpm vitest run --filter @riff3d/adapter-playcanvas __tests__/drag-preview.test.ts` -- tests pass.
    Run `cd /home/frank/riff3d && pnpm turbo typecheck` -- no type errors.
    Run `cd /home/frank/riff3d && pnpm turbo test` -- all tests pass.
  </verify>
  <done>
    - DragPreviewManager created with ghost entity lifecycle and ground plane raycasting
    - Ghost uses translucent material (opacity 0.5) for visual preview
    - Y=0 plane intersection provides cursor-following without physics dependency
    - Drop creates real entity via PatchOps callback
    - Unit tests verify raycasting math and ghost lifecycle
    - Wired into viewport-canvas.tsx with DOM drag events
  </done>
</task>

<task type="auto">
  <name>Task 2: Define tiered performance budgets and update conformance benchmarks</name>
  <files>
    packages/conformance/src/budgets.ts
    packages/conformance/__tests__/benchmarks.test.ts
  </files>
  <action>
    **1. Create performance budget definitions (`packages/conformance/src/budgets.ts`):**

    Define the tiered budget structure as a typed constant:

    ```typescript
    export interface TieredBudget {
      metric: string;
      unit: string;
      excellent: number;
      pass: number;
      fail: number;
      direction: "lower-is-better" | "higher-is-better";
      measurable: "ci" | "local-only";
      description: string;
    }

    export interface SimpleBudget {
      metric: string;
      unit: string;
      pass: number;
      fail: number;
      direction: "lower-is-better" | "higher-is-better";
      measurable: "ci" | "local-only";
      description: string;
    }
    ```

    **Tiered budgets (Excellent / Pass / Fail):**

    | Metric | Excellent | Pass | Fail | Direction | Measurable |
    |--------|-----------|------|------|-----------|------------|
    | FPS editing idle ~20 entities | >= 72 | >= 45 | < 30 | higher | local-only |
    | FPS editing idle ~100 entities | >= 60 | >= 30 | < 20 | higher | local-only |
    | Scene load time (small fixture) | < 100ms | < 500ms | >= 1000ms | lower | local-only |
    | Scene load time (adversarial fixture) | < 300ms | < 1000ms | >= 3000ms | lower | local-only |
    | Editor total memory (heap) | < 100MB | < 200MB | >= 400MB | lower | local-only |
    | IR compilation time (small) | < 25ms | < 50ms | >= 100ms | lower | ci |
    | IR compilation time (large) | < 250ms | < 1000ms | >= 2000ms | lower | ci |

    **Simple budgets (Pass / Fail):**

    | Metric | Pass | Fail | Direction | Measurable |
    |--------|------|------|-----------|------------|
    | PatchOp single apply | < 1ms | >= 5ms | lower | ci |
    | PatchOp batch of 100 | < 50ms | >= 200ms | lower | ci |
    | Scene rebuild ~20 entities | < 100ms | >= 500ms | lower | local-only |
    | ECSON round-trip loss (portable) | 0% | > 0% | lower | ci |

    Export the budgets as named constants: `TIERED_BUDGETS` and `SIMPLE_BUDGETS`.

    Also export a helper function:
    ```typescript
    export function checkBudget(metric: string, value: number): "excellent" | "pass" | "fail" { ... }
    ```

    **2. Update conformance benchmarks (`__tests__/benchmarks.test.ts`):**

    The existing benchmarks use hardcoded thresholds (from 01-06: 2x CI margin with 50/200/1000ms baselines). Update them to import from `budgets.ts`:

    - Replace hardcoded threshold values with imports from `TIERED_BUDGETS` / `SIMPLE_BUDGETS`
    - Add `describe` blocks for each budget category (compilation, PatchOps, round-trip)
    - For CI-measurable budgets, assert `value < budget.fail` (must pass) and optionally log whether the value hits `excellent` or `pass` tier
    - For local-only budgets, add skipped test shells with `it.skip("FPS budget -- local only", ...)` so they're visible in the test report but don't fail CI

    **3. Export budgets from conformance package:**

    Add to `packages/conformance/src/index.ts`:
    ```typescript
    export { TIERED_BUDGETS, SIMPLE_BUDGETS, checkBudget, type TieredBudget, type SimpleBudget } from "./budgets";
    ```

    This allows the editor app (and Playwright tests in 03-06) to import budget definitions for runtime measurement.
  </action>
  <verify>
    Run `cd /home/frank/riff3d && pnpm vitest run --filter @riff3d/conformance` -- benchmarks pass with imported budget thresholds.
    Run `cd /home/frank/riff3d && pnpm turbo typecheck` -- no type errors.
    Run `cd /home/frank/riff3d && pnpm turbo test` -- all tests pass.
    Verify `packages/conformance/src/budgets.ts` exports at least 7 tiered budgets and 4 simple budgets.
  </verify>
  <done>
    - Tiered performance budgets (Excellent/Pass/Fail) defined for all key metrics
    - Excellent tier targets WebXR-ready performance (72+ FPS for VR)
    - CI-measurable budgets (compilation, PatchOps) enforced in conformance benchmarks
    - Local-only budgets (FPS, memory, load time) defined but not CI-enforced
    - `checkBudget()` helper available for runtime budget evaluation
    - Existing benchmarks updated to use centralized budget definitions
  </done>
</task>

</tasks>

<verification>
- `pnpm turbo test` passes across entire monorepo
- `pnpm turbo typecheck` passes
- DragPreviewManager exported from `@riff3d/adapter-playcanvas/editor-tools`
- Performance budgets importable from `@riff3d/conformance`
- `bash scripts/check-adapter-loc.sh` still passes (drag-preview is in editor-tools, not core)
</verification>

<success_criteria>
Drag-preview ghost feature is implemented with translucent entity, Y=0 ground plane raycasting, and PatchOps-based entity creation on drop. Performance budgets define formal tiered thresholds that satisfy Phase 3 success criterion #4, with an Excellent tier targeting WebXR readiness.
</success_criteria>

<output>
After completion, create `.planning/phases/03-review-gate-foundation/03-05-SUMMARY.md`
</output>
