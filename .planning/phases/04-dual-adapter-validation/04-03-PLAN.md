---
phase: 04-dual-adapter-validation
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - apps/editor/src/stores/slices/engine-slice.ts
  - apps/editor/src/stores/editor-store.ts
  - apps/editor/src/components/editor/viewport/viewport-provider.tsx
  - apps/editor/src/components/editor/viewport/viewport-canvas.tsx
  - apps/editor/src/components/editor/shell/top-bar.tsx
  - apps/editor/src/components/editor/shell/engine-switcher.tsx
  - apps/editor/src/components/editor/inspector/engine-tuning-section.tsx
  - apps/editor/src/components/editor/inspector/inspector-panel.tsx
  - apps/editor/src/components/editor/shell/editor-shell.tsx
  - apps/editor/src/components/ui/confirm-dialog.tsx
autonomous: true
requirements:
  - PORT-03

must_haves:
  truths:
    - "Engine switcher appears in the top bar with subtle engine icon indicating active engine"
    - "Clicking the switcher shows a confirmation dialog before switching engines"
    - "Switching engines shows a loading overlay while the new engine initializes"
    - "Camera position carries over when switching engines; selection resets"
    - "Engine switcher is disabled during play-test mode"
    - "Engine choice persists as a project-level setting in ECSON metadata"
    - "New projects default to PlayCanvas"
    - "Inspector shows collapsible 'Engine Tuning' section when an entity is selected"
    - "Only active engine's tuning is visible by default; subtle toggle to peek at other engine (dimmed/read-only)"
    - "Subtle badge on engine switcher indicates when custom tuning is applied"
    - "Tooltip on engine switcher notes rendering may vary between engines"
  artifacts:
    - path: "apps/editor/src/stores/slices/engine-slice.ts"
      provides: "Engine state management (active engine, switching state)"
      exports: ["createEngineSlice", "EngineSlice"]
    - path: "apps/editor/src/components/editor/shell/engine-switcher.tsx"
      provides: "Engine switcher component for top bar"
      exports: ["EngineSwitcher"]
    - path: "apps/editor/src/components/editor/inspector/engine-tuning-section.tsx"
      provides: "Collapsible engine tuning section in inspector"
      exports: ["EngineTuningSection"]
    - path: "apps/editor/src/components/ui/confirm-dialog.tsx"
      provides: "Reusable confirmation dialog component"
      exports: ["ConfirmDialog"]
  key_links:
    - from: "apps/editor/src/components/editor/viewport/viewport-canvas.tsx"
      to: "@riff3d/adapter-babylon"
      via: "dynamic import for Babylon adapter based on engine slice state"
      pattern: "BabylonAdapter|adapter-babylon"
    - from: "apps/editor/src/stores/slices/engine-slice.ts"
      to: "apps/editor/src/stores/slices/scene-slice.ts"
      via: "reads ecsonDoc metadata for preferredEngine"
      pattern: "preferredEngine|metadata"
    - from: "apps/editor/src/components/editor/shell/engine-switcher.tsx"
      to: "apps/editor/src/stores/slices/engine-slice.ts"
      via: "dispatches switchEngine action"
      pattern: "switchEngine"
---

<objective>
Implement engine switching UI and engine tuning visibility in the editor, allowing users to switch between PlayCanvas and Babylon.js rendering and view/edit engine-specific tuning parameters.

Purpose: This enables users to validate their scenes on both engines and configure engine-specific settings, proving the IR's engine-agnosticism in practice.

Output: Engine switcher in top bar, confirmation dialog, loading overlay during switch, camera state preservation, engine tuning section in inspector, and project-level engine persistence.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dual-adapter-validation/04-RESEARCH.md
@.planning/phases/04-dual-adapter-validation/04-CONTEXT.md
@.planning/phases/04-dual-adapter-validation/04-01-SUMMARY.md
@.planning/phases/04-dual-adapter-validation/04-02-SUMMARY.md

# Delta types (from 04-02, needed for viewport delta routing):
@packages/canonical-ir/src/delta.ts

# Editor structure:
@apps/editor/src/components/editor/shell/editor-shell.tsx
@apps/editor/src/components/editor/shell/top-bar.tsx
@apps/editor/src/components/editor/viewport/viewport-provider.tsx
@apps/editor/src/components/editor/viewport/viewport-canvas.tsx
@apps/editor/src/components/editor/inspector/inspector-panel.tsx
@apps/editor/src/stores/editor-store.ts
@apps/editor/src/stores/slices/scene-slice.ts
@apps/editor/src/stores/slices/playtest-slice.ts
@apps/editor/src/stores/slices/ui-slice.ts

# Adapter types (from 04-01):
@packages/canonical-ir/src/types/engine-adapter.ts

# ECSON metadata schema:
@packages/ecson/src/schemas/scene-document.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Engine state slice and viewport generalization</name>
  <files>
    apps/editor/src/stores/slices/engine-slice.ts
    apps/editor/src/stores/editor-store.ts
    apps/editor/src/components/editor/viewport/viewport-provider.tsx
    apps/editor/src/components/editor/viewport/viewport-canvas.tsx
    apps/editor/src/components/editor/shell/editor-shell.tsx
  </files>
  <action>
    **1. Create `apps/editor/src/stores/slices/engine-slice.ts`:**

    ```typescript
    export type EngineType = "playcanvas" | "babylon";

    export interface EngineSlice {
      /** Currently active rendering engine */
      activeEngine: EngineType;
      /** Whether an engine switch is in progress */
      isSwitchingEngine: boolean;
      /** Switch to a different engine */
      switchEngine: (engine: EngineType) => void;
      /** Set switching state (called by viewport during async init) */
      setEngineSwitching: (switching: boolean) => void;
    }
    ```

    Implementation:
    - `activeEngine` defaults to `"playcanvas"` (per locked decision: new projects default to PlayCanvas)
    - `switchEngine(engine)`: Sets `activeEngine` and `isSwitchingEngine: true`. The viewport component reacts to `activeEngine` changes.
    - `setEngineSwitching(switching)`: Called by viewport when the adapter finishes initializing (sets to false) or starts initializing (sets to true)
    - Read `preferredEngine` from `ecsonDoc.metadata` in `loadProject` to restore engine choice. Add a cross-slice read: after `loadProject` sets `ecsonDoc`, check `ecsonDoc.metadata?.preferredEngine` and if it's `"babylon"`, set `activeEngine = "babylon"`.

    For the cross-slice interaction with loadProject: use a `subscribeWithSelector` listener on `ecsonDoc` changes that reads `metadata.preferredEngine` and updates `activeEngine`. OR, add the engine preference read directly in the engine slice's `loadEnginePreference(doc)` method called from editor-shell after `loadProject`.

    SIMPLEST approach: In editor-shell.tsx, after `loadProject(ecsonDoc)`, also call `editorStore.getState().switchEngine(ecsonDoc.metadata?.preferredEngine || "playcanvas")` synchronously. This avoids cross-slice coupling.

    **2. Update `apps/editor/src/stores/editor-store.ts`:**

    Add `EngineSlice` to the composed store:
    ```typescript
    import { createEngineSlice, type EngineSlice } from "./slices/engine-slice";

    export type EditorState = UISlice & SceneSlice & ViewportSlice & SaveSlice & PlaytestSlice & EngineSlice;
    ```

    Add `...createEngineSlice(...args)` to the store composition.

    **3. Generalize `apps/editor/src/components/editor/viewport/viewport-provider.tsx`:**

    Change from PlayCanvas-specific to engine-agnostic:
    ```typescript
    import type { EngineAdapter } from "@riff3d/canonical-ir";

    interface ViewportContextValue {
      adapterRef: React.RefObject<EngineAdapter | null>;
    }
    ```

    Update `useViewportAdapter` return type to `React.RefObject<EngineAdapter | null>`.

    This is a BREAKING change for components that access PlayCanvas-specific methods (gizmos, selection). Those components should use `instanceof PlayCanvasAdapter` checks. The types file re-exports EngineAdapter so most imports don't change.

    **4. Major rework of `apps/editor/src/components/editor/viewport/viewport-canvas.tsx`:**

    This is the most complex change. The component currently hardcodes `PlayCanvasAdapter`. It needs to:

    a) Read `activeEngine` from the store to decide which adapter to create
    b) React to `activeEngine` changes by disposing the old adapter and creating a new one
    c) Serialize camera state before disposing, restore after initializing
    d) Handle the loading overlay during switch
    e) Only initialize PlayCanvas-specific editor tools (gizmos, selection, grid, drag preview) when PlayCanvas is active

    **Approach -- canvas element replacement per research recommendation:**

    Instead of reusing the same canvas element, create a fresh canvas on each engine switch. This avoids WebGL context lifecycle issues.

    Use a `key` prop on the canvas element derived from `activeEngine` + a switch counter. When the key changes, React unmounts and remounts the canvas, giving the new adapter a fresh element.

    Wait -- this would destroy the entire effect and re-run it. That's actually the simplest approach: make `activeEngine` a dependency of the main useEffect. When engine changes, cleanup runs (disposing old adapter), and the effect re-runs (creating new adapter).

    BUT: we need to serialize camera state BEFORE cleanup and restore AFTER init. Use a ref to store the serialized camera state during the switch.

    **Implementation strategy:**

    ```typescript
    const activeEngine = useEditorStore((s) => s.activeEngine);
    const isSwitchingEngine = useEditorStore((s) => s.isSwitchingEngine);
    const pendingCameraState = useRef<SerializedCameraState | null>(null);
    ```

    The main useEffect depends on `[activeEngine]`. On re-run:
    1. Show loading overlay
    2. If adapterRef.current exists, serialize camera state into pendingCameraState ref
    3. Cleanup runs automatically (disposes old adapter)
    4. Create new adapter (PlayCanvasAdapter or BabylonAdapter based on activeEngine)
    5. Initialize, load scene, restore camera from pendingCameraState
    6. Initialize editor tools (gizmos/selection/grid only if PlayCanvas)
    7. Hide loading overlay, clear selection (per locked decision: selection resets on switch)

    For Babylon adapter: import it dynamically to avoid loading Babylon.js when not needed:
    ```typescript
    const { BabylonAdapter } = await import("@riff3d/adapter-babylon");
    ```

    For PlayCanvas editor tools (gizmos, selection, grid, drag preview): only initialize when `activeEngine === "playcanvas"`. When Babylon is active, these tools are not available (Babylon-specific editor tools are Phase 5+ scope). Users can still edit via the inspector and hierarchy panels.

    Reset `isInitialized.current = false` when activeEngine changes so the effect can re-run.

    **CRITICAL -- Delta-aware subscriber (from 04-02 scene-slice integration):**

    The `canonicalScene` subscriber in viewport-canvas.tsx MUST be delta-aware. When 04-02 adds `lastDelta` to the scene slice, the subscriber needs to check it:

    ```typescript
    // Subscribe to canonicalScene changes -> apply delta or rebuild
    docUnsub = editorStore.subscribe(
      (state) => state.canonicalScene,
      (canonicalScene) => {
        if (!canonicalScene) return;
        const { lastDelta } = editorStore.getState();
        if (lastDelta && lastDelta.type !== "full-rebuild") {
          adapter.applyDelta(lastDelta);
        } else {
          adapter.rebuildScene(canonicalScene);
        }
        // Update entity map references (defensive, cheap for non-structural deltas)
        const newEntityMap = adapter.getTypedEntityMap?.() ?? adapter.getEntityMap();
        gizmoManager?.updateEntityMap(newEntityMap);
        selectionManager?.updateEntityMap(newEntityMap);
      },
    );
    ```

    This wiring is essential for the delta system to actually work end-to-end. Without it, every property edit would still trigger a full rebuild.

    **Save engine preference:** When `switchEngine` is called, also dispatch a SetProperty PatchOp to update `ecsonDoc.metadata.preferredEngine`. Use the `__environment__` virtual entity or a new metadata path. Since metadata is on the document root and SetProperty expects entityId, use a convention: if entityId is `"__document__"`, the path targets `metadata.*`.

    Actually simpler: Just directly mutate `ecsonDoc.metadata.preferredEngine` in the engine slice without a PatchOp (this is a system-level setting, not a user edit -- similar to the approved exceptions for loadProject). Store the preference and let auto-save persist it.

    Or even simpler: Write the preference directly to Supabase as a column on the projects table, not in ECSON. But the locked decision says "project-level setting stored with the project" and ECSON metadata is where project settings live.

    Best approach: In `switchEngine`, after setting `activeEngine`, also update `ecsonDoc.metadata.preferredEngine` directly (non-PatchOp mutation, matching the system-level exception pattern). Bump `docVersion` to trigger auto-save.

    **5. Update `apps/editor/src/components/editor/shell/editor-shell.tsx`:**

    After `loadProject(ecsonDoc)`, read `ecsonDoc.metadata?.preferredEngine` and if it's a valid engine type, call `switchEngine()` with it. This ensures the correct engine loads on project open.

    Also: the `ViewportCanvas` dynamic import stays as-is (it already loads with ssr:false). The Babylon adapter is dynamically imported inside viewport-canvas.tsx.
  </action>
  <verify>
    `pnpm turbo run typecheck` passes.
    Editor loads with PlayCanvas by default (existing behavior preserved).
    Engine slice state is accessible from store.
    No regressions in existing editor functionality.
  </verify>
  <done>
    Engine state slice manages activeEngine/isSwitchingEngine. ViewportProvider is generalized to EngineAdapter. ViewportCanvas creates the correct adapter based on activeEngine. Camera state serializes across switches. Engine preference reads from ECSON metadata on project load.
  </done>
</task>

<task type="auto">
  <name>Task 2: Engine switcher UI, tuning inspector, and confirmation dialog</name>
  <files>
    apps/editor/src/components/editor/shell/engine-switcher.tsx
    apps/editor/src/components/editor/shell/top-bar.tsx
    apps/editor/src/components/ui/confirm-dialog.tsx
    apps/editor/src/components/editor/inspector/engine-tuning-section.tsx
    apps/editor/src/components/editor/inspector/inspector-panel.tsx
  </files>
  <action>
    **1. Create `apps/editor/src/components/ui/confirm-dialog.tsx`:**

    A reusable confirmation dialog component using a modal overlay:
    - Props: `open`, `onConfirm`, `onCancel`, `title`, `message`, `confirmLabel`, `cancelLabel`
    - Centered modal with backdrop blur
    - Tailwind styled to match existing editor theme (dark, var-based colors)
    - Confirm button with accent color, cancel button with muted color
    - Escape key and backdrop click cancel
    - Focus trap on the confirm button when opened

    **2. Create `apps/editor/src/components/editor/shell/engine-switcher.tsx`:**

    Per locked decisions:
    - Lives in the main editor toolbar (top bar)
    - Active engine indicated by a subtle engine icon (not text label)
    - Clicking shows confirmation dialog ("Switch to Babylon.js? Scene will reload." or vice versa)
    - Disabled during play-test mode
    - Brief tooltip noting rendering may vary slightly between engines
    - Subtle badge/dot if current engine has custom tuning applied

    Implementation:
    - Read `activeEngine`, `isSwitchingEngine`, `isPlaying` from store
    - Use two icons: a PlayCanvas icon (a simple "P" styled icon or a generic game controller) and a Babylon icon (a "B" styled icon or a different icon). Since we don't have official logo SVGs, use simple styled letter badges: a small circle with "PC" or "BJ" in it, or use `lucide-react` icons like `Box` for PlayCanvas and `Hexagon` for Babylon. Claude's discretion on exact icons.
    - Button shows current engine icon. Click opens confirmation dialog.
    - When switching, button shows a loading spinner.
    - Disabled state (during play mode): `opacity-50 cursor-not-allowed pointer-events-none`
    - Tooltip: `title="Switch rendering engine (rendering may vary slightly between engines)"`
    - Tuning badge: Read `ecsonDoc.metadata` for tuning keys. If the active engine key exists in any entity's tuning record, show a small colored dot (e.g., `bg-cyan-400 w-1.5 h-1.5 rounded-full`) in the corner of the icon.

    Confirmation dialog:
    - Title: "Switch Rendering Engine"
    - Message: "Switch to {targetEngine}? The scene will reload and rendering may look slightly different. Selection will be reset."
    - Confirm: "Switch Engine"
    - Cancel: "Cancel"

    On confirm:
    - Call `editorStore.getState().setSelection([])` to reset selection
    - Call `editorStore.getState().switchEngine(targetEngine)`

    **3. Update `apps/editor/src/components/editor/shell/top-bar.tsx`:**

    Add the `EngineSwitcher` component. Place it between the project name (left section) and the play controls (center). This keeps it visible and accessible.

    ```tsx
    {/* Center-left: Engine switcher */}
    <div className="flex items-center gap-3">
      <EngineSwitcher />
      <PlayControls />
    </div>
    ```

    Adjust the flex layout so the engine switcher sits naturally next to play controls without crowding.

    **4. Create `apps/editor/src/components/editor/inspector/engine-tuning-section.tsx`:**

    Per locked decisions:
    - Collapsible "Engine Tuning" section in the inspector
    - Only active engine's tuning visible by default
    - Subtle toggle to peek at other engine's tuning (dimmed/read-only)
    - Supported at both scene-level and per-entity level
    - Per-entity only when user explicitly opts in (not on every entity by default)

    Implementation:
    - Props: `entityId: string | null` (null = scene-level tuning)
    - Read `activeEngine` from store
    - Read tuning data from `ecsonDoc.entities[entityId].tuning` (entity-level) or `ecsonDoc.environment` (scene-level)
    - If entity has no tuning for the active engine, show "No tuning configured" with an "Add Tuning" button
    - When tuning exists, render key-value pairs as editable fields (text inputs for string/number values)
    - Editing a tuning value dispatches a SetProperty PatchOp with path `tuning.{engineName}.{key}`
    - Collapsible header: `<button>` with chevron icon, "Engine Tuning" label, and the engine icon
    - "Peek other engine" toggle: small eye icon button next to the header. When toggled, shows the other engine's tuning below with `opacity-50 pointer-events-none` styling

    For Phase 4 scope: tuning values are displayed as raw key-value pairs (JSON-like). Typed tuning editors (e.g., shadow resolution slider) are future work.

    **5. Update `apps/editor/src/components/editor/inspector/inspector-panel.tsx`:**

    Add the `EngineTuningSection` at the bottom of the inspector panel:
    - When an entity is selected: show entity tuning section (with entityId)
    - When no entity selected (environment panel mode): show scene-level tuning section (entityId=null)
    - The section is always present but collapsed by default

    Import and render:
    ```tsx
    <EngineTuningSection entityId={selectedEntityIds[0] ?? null} />
    ```
  </action>
  <verify>
    `pnpm turbo run typecheck` passes.
    Engine switcher renders in top bar with correct icon.
    Clicking switcher opens confirmation dialog (manually verify in browser if possible).
    Engine tuning section renders in inspector (collapsed by default).
    Switcher disabled during play mode.
  </verify>
  <done>
    Engine switcher in top bar with confirmation dialog, loading overlay, and engine icons. Inspector shows collapsible engine tuning section with active engine tuning visible and peek toggle for other engine. Engine preference persists in ECSON metadata.
  </done>
</task>

</tasks>

<verification>
- Engine switcher renders in top bar, shows correct engine icon
- Confirmation dialog appears when clicking switcher
- Engine switch disposes old adapter, creates new one, restores camera
- Selection resets on switch
- Switcher disabled during play-test mode
- Engine tuning section visible in inspector
- ECSON metadata stores preferredEngine
- Tooltip on switcher about rendering differences
</verification>

<success_criteria>
- User can switch between PlayCanvas and Babylon.js in the editor
- Camera position carries over on switch; selection resets
- Engine choice persists with the project (ECSON metadata)
- Engine tuning section shows in inspector with active/peek toggle
- No regressions in existing editor functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-dual-adapter-validation/04-03-SUMMARY.md`
</output>
