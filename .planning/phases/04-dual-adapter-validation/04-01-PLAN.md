---
phase: 04-dual-adapter-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/canonical-ir/src/types/engine-adapter.ts
  - packages/canonical-ir/src/types/ir-delta.ts
  - packages/canonical-ir/src/types/index.ts
  - packages/canonical-ir/src/index.ts
  - packages/adapter-playcanvas/src/types.ts
  - packages/adapter-playcanvas/src/index.ts
  - packages/adapter-babylon/package.json
  - packages/adapter-babylon/tsconfig.json
  - packages/adapter-babylon/vitest.config.ts
  - packages/adapter-babylon/src/index.ts
  - packages/adapter-babylon/src/types.ts
  - packages/adapter-babylon/src/adapter.ts
  - packages/adapter-babylon/src/scene-builder.ts
  - packages/adapter-babylon/src/environment.ts
  - packages/adapter-babylon/src/component-mappers/index.ts
  - packages/adapter-babylon/src/component-mappers/mesh-renderer.ts
  - packages/adapter-babylon/src/component-mappers/material.ts
  - packages/adapter-babylon/src/component-mappers/light.ts
  - packages/adapter-babylon/src/component-mappers/camera.ts
  - packages/adapter-babylon/__tests__/helpers/babylon-mocks.ts
  - packages/adapter-babylon/__tests__/scene-builder.test.ts
  - packages/adapter-babylon/__tests__/component-mappers.test.ts
  - packages/adapter-babylon/__tests__/environment.test.ts
  - pnpm-workspace.yaml
autonomous: true
requirements:
  - ADPT-02

must_haves:
  truths:
    - "EngineAdapter interface and IRDelta type live in @riff3d/canonical-ir (shared by both adapters)"
    - "Babylon.js adapter builds a scene graph from any valid CanonicalScene (nodes, transforms, components, environment)"
    - "All 7 primitive types (box, sphere, cylinder, capsule, cone, plane, torus) render in Babylon"
    - "PBR materials (baseColor, metallic, roughness, emissive, opacity, doubleSided) apply correctly in Babylon"
    - "All 3 light types (directional, point, spot) create correct Babylon light nodes"
    - "Cameras (perspective, orthographic) create correct Babylon camera nodes"
    - "Environment settings (ambient, fog, skybox color) apply to Babylon scene"
    - "Unit tests pass for scene-builder, component-mappers, and environment modules"
  artifacts:
    - path: "packages/canonical-ir/src/types/engine-adapter.ts"
      provides: "Shared EngineAdapter interface with applyDelta method"
      exports: ["EngineAdapter", "SerializedCameraState"]
    - path: "packages/canonical-ir/src/types/ir-delta.ts"
      provides: "IRDelta discriminated union type for incremental updates"
      exports: ["IRDelta"]
    - path: "packages/adapter-babylon/src/adapter.ts"
      provides: "BabylonAdapter class implementing EngineAdapter"
      exports: ["BabylonAdapter"]
    - path: "packages/adapter-babylon/src/scene-builder.ts"
      provides: "buildScene function for Babylon.js"
      exports: ["buildScene", "destroySceneEntities"]
    - path: "packages/adapter-babylon/src/environment.ts"
      provides: "applyEnvironment for Babylon scene"
      exports: ["applyEnvironment", "getSkyboxColor"]
  key_links:
    - from: "packages/adapter-babylon/src/adapter.ts"
      to: "@riff3d/canonical-ir"
      via: "imports EngineAdapter interface and CanonicalScene type"
      pattern: "import.*EngineAdapter.*canonical-ir"
    - from: "packages/adapter-playcanvas/src/types.ts"
      to: "@riff3d/canonical-ir"
      via: "re-exports EngineAdapter from canonical-ir (backward compat)"
      pattern: "export.*EngineAdapter.*canonical-ir"
    - from: "packages/adapter-babylon/src/scene-builder.ts"
      to: "packages/adapter-babylon/src/component-mappers"
      via: "applyComponents call for each IR node"
      pattern: "applyComponents"
---

<objective>
Build the Babylon.js adapter package that renders Canonical IR scenes using Babylon.js, and extract the shared EngineAdapter interface + IRDelta type to the canonical-ir package.

Purpose: This proves the Canonical IR is truly engine-agnostic by implementing a second adapter that reads the same IR as PlayCanvas. The extracted interface establishes the shared contract both adapters implement.

Output: New `@riff3d/adapter-babylon` package with full scene rendering, and shared `EngineAdapter`/`IRDelta` types in `@riff3d/canonical-ir`.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dual-adapter-validation/04-RESEARCH.md
@.planning/research/FUTURE_ENGINE_CONSIDERATIONS.md
@.planning/research/BABYLON_ADVANCE_RESEARCH.md

# Existing adapter to mirror:
@packages/adapter-playcanvas/src/adapter.ts
@packages/adapter-playcanvas/src/types.ts
@packages/adapter-playcanvas/src/scene-builder.ts
@packages/adapter-playcanvas/src/environment.ts
@packages/adapter-playcanvas/src/component-mappers/index.ts
@packages/adapter-playcanvas/src/component-mappers/mesh-renderer.ts
@packages/adapter-playcanvas/src/component-mappers/material.ts
@packages/adapter-playcanvas/src/component-mappers/light.ts
@packages/adapter-playcanvas/src/component-mappers/camera.ts

# Existing IR types:
@packages/canonical-ir/src/types/canonical-scene.ts
@packages/canonical-ir/src/types/canonical-node.ts
@packages/canonical-ir/src/types/canonical-component.ts
@packages/canonical-ir/src/types/canonical-environment.ts
@packages/canonical-ir/src/index.ts

# Existing test patterns:
@packages/adapter-playcanvas/__tests__/helpers/pc-mocks.ts
@packages/adapter-playcanvas/__tests__/scene-builder.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract EngineAdapter interface and IRDelta type to canonical-ir</name>
  <files>
    packages/canonical-ir/src/types/engine-adapter.ts
    packages/canonical-ir/src/types/ir-delta.ts
    packages/canonical-ir/src/types/index.ts
    packages/canonical-ir/src/index.ts
    packages/adapter-playcanvas/src/types.ts
    packages/adapter-playcanvas/src/index.ts
  </files>
  <action>
    **1. Create `packages/canonical-ir/src/types/engine-adapter.ts`:**

    Extract the `EngineAdapter` interface from `packages/adapter-playcanvas/src/types.ts` into canonical-ir. This is the shared contract both adapters implement.

    Add these methods to the existing interface:
    - `applyDelta(delta: IRDelta): void` -- incremental scene update (04-02 implements, stub signature now)
    - `serializeCameraState(): SerializedCameraState` -- camera state for engine switching
    - `restoreCameraState(state: SerializedCameraState): void` -- restore camera after switch

    Define `SerializedCameraState`:
    ```typescript
    export interface SerializedCameraState {
      position: { x: number; y: number; z: number };
      rotation: { x: number; y: number; z: number; w: number };
      mode: "fly" | "orbit";
    }
    ```

    Import `CanonicalScene` and `IRDelta` from sibling type files. Do NOT import from Zod schemas -- these are pure TypeScript interfaces.

    **2. Create `packages/canonical-ir/src/types/ir-delta.ts`:**

    Define the `IRDelta` discriminated union type:
    ```typescript
    export type IRDelta =
      | { type: "node-transform"; nodeId: string; transform: { position?: Vec3; rotation?: Quat; scale?: Vec3 } }
      | { type: "node-visibility"; nodeId: string; visible: boolean }
      | { type: "component-property"; nodeId: string; componentIndex: number; property: string; value: unknown }
      | { type: "environment"; path: string; value: unknown }
      | { type: "full-rebuild" }  // fallback for structural changes
    ```

    Use inline Vec3/Quat interfaces (not Zod schemas -- these are pure runtime types):
    ```typescript
    interface Vec3 { x: number; y: number; z: number }
    interface Quat { x: number; y: number; z: number; w: number }
    ```

    **3. Update `packages/canonical-ir/src/types/index.ts`:**

    Add exports for the new files:
    ```typescript
    export type { EngineAdapter, SerializedCameraState } from "./engine-adapter";
    export type { IRDelta } from "./ir-delta";
    ```

    **4. Update `packages/canonical-ir/src/index.ts`:**

    Ensure `EngineAdapter`, `SerializedCameraState`, and `IRDelta` are re-exported from the package root.

    **5. Update `packages/adapter-playcanvas/src/types.ts`:**

    Change to re-export from canonical-ir for backward compatibility:
    ```typescript
    export type { EngineAdapter, SerializedCameraState } from "@riff3d/canonical-ir";
    export type { IRDelta } from "@riff3d/canonical-ir";
    ```

    Keep the `CameraMode` interface locally since it's PlayCanvas-specific.

    **6. Update `packages/adapter-playcanvas/src/index.ts`:**

    Update the re-export line to match the new source:
    ```typescript
    export type { EngineAdapter, CameraMode } from "./types";
    ```

    CameraMode stays local, EngineAdapter now re-exports from canonical-ir through types.ts.

    **CRITICAL:** Verify that `packages/adapter-playcanvas/package.json` already has `@riff3d/canonical-ir` as a dependency (it should from Phase 1). If not, add it.

    Run `pnpm turbo run typecheck --filter=@riff3d/adapter-playcanvas` to verify no breakage.
  </action>
  <verify>
    `pnpm turbo run typecheck --filter=@riff3d/canonical-ir --filter=@riff3d/adapter-playcanvas` passes.
    All existing PlayCanvas adapter tests still pass: `pnpm turbo run test --filter=@riff3d/adapter-playcanvas`
  </verify>
  <done>
    EngineAdapter interface and IRDelta type live in @riff3d/canonical-ir. PlayCanvas adapter re-exports for backward compatibility. No test regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create @riff3d/adapter-babylon package with full scene rendering</name>
  <files>
    packages/adapter-babylon/package.json
    packages/adapter-babylon/tsconfig.json
    packages/adapter-babylon/vitest.config.ts
    packages/adapter-babylon/src/index.ts
    packages/adapter-babylon/src/types.ts
    packages/adapter-babylon/src/adapter.ts
    packages/adapter-babylon/src/scene-builder.ts
    packages/adapter-babylon/src/environment.ts
    packages/adapter-babylon/src/component-mappers/index.ts
    packages/adapter-babylon/src/component-mappers/mesh-renderer.ts
    packages/adapter-babylon/src/component-mappers/material.ts
    packages/adapter-babylon/src/component-mappers/light.ts
    packages/adapter-babylon/src/component-mappers/camera.ts
    packages/adapter-babylon/__tests__/helpers/babylon-mocks.ts
    packages/adapter-babylon/__tests__/scene-builder.test.ts
    packages/adapter-babylon/__tests__/component-mappers.test.ts
    packages/adapter-babylon/__tests__/environment.test.ts
    pnpm-workspace.yaml
  </files>
  <action>
    **1. Create package scaffold:**

    `packages/adapter-babylon/package.json`:
    - name: `@riff3d/adapter-babylon`
    - dependencies: `@babylonjs/core` (~8.52), `@riff3d/canonical-ir` (workspace:*)
    - devDependencies: `vitest` (catalog:), `typescript` (catalog:)
    - exports: `"./src/index.ts"` (source-based, matching other packages)
    - scripts: `test`, `typecheck`, `lint`

    `packages/adapter-babylon/tsconfig.json`: Extend root tsconfig, include `src/**/*` and `__tests__/**/*`.

    `packages/adapter-babylon/vitest.config.ts`: Match PlayCanvas adapter config pattern.

    Ensure `pnpm-workspace.yaml` includes `packages/adapter-babylon` (should be covered by `packages/*` glob).

    Run `pnpm install` to link the new package.

    **2. Create `packages/adapter-babylon/src/adapter.ts` -- BabylonAdapter class:**

    Mirror the PlayCanvas adapter structure exactly. The class:
    - Implements `EngineAdapter` from `@riff3d/canonical-ir`
    - Holds: `engine: Engine | null`, `scene: Scene | null`, `entityMap: Map<string, TransformNode>`, `editorCamera: UniversalCamera | null`, `currentScene: CanonicalScene | null`, `canvas: HTMLCanvasElement | null`, `inPlayMode: boolean`
    - `initialize(canvas)`: Create `Engine` (preserveDrawingBuffer: true, stencil: true), create `Scene`, set dark blue clear color (Color4(0.05, 0.05, 0.12, 1)), start render loop, create editor camera (UniversalCamera at position 0,3,-8 looking at origin), call resize
    - `loadScene(scene)`: Call `buildScene(this.scene, scene)`, call `applyEnvironment(this.scene, scene.environment)`, update editor camera clear color from skybox, dispatch `__sceneReady` event (matching PlayCanvas pattern)
    - `rebuildScene(scene)`: Call `destroySceneEntities(entityMap)`, then `loadScene(scene)`
    - `applyDelta(delta)`: Stub for now -- log warning "applyDelta not yet implemented, falling back to rebuild" and call `rebuildScene` with currentScene. (04-02 will implement)
    - `getEntityMap()`: Return entityMap as `Map<string, unknown>`
    - `serializeCameraState()`: Return position/rotation/mode from editor camera
    - `restoreCameraState(state)`: Apply position/rotation to editor camera
    - `resize()`: Call `engine.resize()`
    - `setPlayMode(playing)`: No-op for Phase 4 (Babylon play mode deferred)
    - `setTimeScale(scale)`: No-op stub
    - `isInPlayMode()`: Return inPlayMode
    - `dispose()`: Dispose scene, dispose engine, clear entityMap, null all refs

    CRITICAL BABYLON PATTERNS:
    - Always use `node.rotationQuaternion` (never `node.rotation` Euler)
    - Use `PBRMetallicRoughnessMaterial` (roughness direct, no inversion)
    - FOV and spot angles: degrees to radians conversion (`* Math.PI / 180`)
    - Editor camera: `detachControl()` on scene cameras (same as PlayCanvas)
    - `node.id = irNodeId` (string) for entity map lookup (NOT `node.uniqueId` which is number)

    **3. Create `packages/adapter-babylon/src/scene-builder.ts`:**

    Mirror PlayCanvas scene-builder. BFS-sorted nodes guarantee parents exist before children.
    - `buildScene(scene: BabylonScene, irScene: CanonicalScene)` -> `{ entityMap, rootNodes }`
    - `createNodeFromIR(scene, node)` -> Creates `TransformNode` or `Mesh` based on components
    - Uses class hierarchy dispatch: if node has MeshRenderer -> use mesh builder (CreateBox, etc.), otherwise -> `new TransformNode(name, scene)`
    - Parent-child: `node.parent = parentNode` (Babylon uses `.parent` property)
    - Set `node.id = irNode.id` for map lookup
    - `destroySceneEntities(entityMap)`: Iterate and call `node.dispose()` on each, then clear map

    **4. Create component mappers:**

    `mesh-renderer.ts`:
    - Import from `@babylonjs/core/Meshes/Builders` for each primitive
    - Map: box -> `CreateBox`, sphere -> `CreateSphere` (segments:32), cylinder -> `CreateCylinder`, capsule -> `CreateCapsule`, cone -> `CreateCylinder` (diameterTop:0), plane -> `CreateGround`, torus -> `CreateTorus`
    - Return the Mesh node

    `material.ts`:
    - `PBRMetallicRoughnessMaterial` from `@babylonjs/core`
    - baseColor -> `mat.baseColor = Color3.FromHexString(hex)` (CRITICAL: handle 3-digit and 6-digit hex, with/without #)
    - metallic -> `mat.metallic` (direct)
    - roughness -> `mat.roughness` (direct -- NO inversion, unlike PlayCanvas)
    - emissive -> `mat.emissiveColor = Color3.FromHexString(hex)`
    - opacity -> `mat.alpha` (and `mat.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND` if < 1)
    - doubleSided -> `mat.backFaceCulling = false; mat.twoSidedLighting = true`

    `light.ts`:
    - directional -> `new DirectionalLight(name, new Vector3(0, -1, 0), scene)` -- direction computed from quaternion later
    - point -> `new PointLight(name, Vector3.Zero(), scene)` with range
    - spot -> `new SpotLight(name, Vector3.Zero(), new Vector3(0, -1, 0), outerAngle * DEG_TO_RAD, exponent, scene)`
    - All lights: set `diffuse` color, `intensity`, `range` where applicable
    - castShadows: create `ShadowGenerator` only if true (deferred to Phase 7 for full implementation)
    - IMPORTANT: Lights in Babylon extend Node, NOT TransformNode. Position is set on the light directly. Direction is derived from quaternion.

    `camera.ts`:
    - `new UniversalCamera(name, Vector3.Zero(), scene)`
    - FOV: `camera.fov = fovDegrees * DEG_TO_RAD`
    - nearClip -> `camera.minZ`, farClip -> `camera.maxZ`
    - Orthographic: `camera.mode = Camera.ORTHOGRAPHIC_CAMERA`, set orthoTop/Bottom from orthoSize
    - `camera.detachControl()` -- scene cameras don't receive input in editor mode

    `index.ts`:
    - `applyComponents(scene, node, irNode)` -- iterates irNode.components, dispatches to correct mapper by type
    - Returns void (mutates the node in place by attaching material or creating light/camera)

    **5. Create `packages/adapter-babylon/src/environment.ts`:**

    - Ambient: `scene.ambientColor = Color3.FromHexString(hex).scale(intensity)`
    - Fog: linear/exponential/exponential2 via `scene.fogMode`, `scene.fogColor`, `scene.fogStart/End`, `scene.fogDensity`
    - Skybox color: `scene.clearColor = Color3.FromHexString(hex).toColor4(1)`
    - `getSkyboxColor(env)` helper matching PlayCanvas pattern

    **6. Create test infrastructure:**

    `__tests__/helpers/babylon-mocks.ts`:
    Follow the globalThis stub pattern from PlayCanvas adapter tests (03-01 decision).
    Create mock classes for: `Engine`, `Scene`, `TransformNode`, `Mesh`, `PBRMetallicRoughnessMaterial`, `DirectionalLight`, `PointLight`, `SpotLight`, `UniversalCamera`, `Vector3`, `Quaternion`, `Color3`, `Color4`, `ShadowGenerator`.
    Each mock captures constructor args and property assignments for assertion.

    Mock the `@babylonjs/core` module in vitest config or via vi.mock.

    `__tests__/scene-builder.test.ts`:
    - Test: empty scene produces empty entityMap
    - Test: single root node creates TransformNode with correct transform
    - Test: parent-child relationship established
    - Test: node with MeshRenderer creates mesh primitive
    - Test: node visibility maps to `node.setEnabled()`
    - Test: destroySceneEntities disposes all nodes

    `__tests__/component-mappers.test.ts`:
    - Test each primitive type (box, sphere, cylinder, capsule, cone, plane, torus)
    - Test PBR material properties (baseColor, metallic, roughness, emissive, opacity, doubleSided)
    - Test roughness is NOT inverted (verify direct pass-through)
    - Test each light type with correct properties
    - Test camera FOV conversion (degrees to radians)
    - Test orthographic camera mode

    `__tests__/environment.test.ts`:
    - Test ambient light color and intensity
    - Test each fog type (linear, exponential, exponential2, disabled)
    - Test skybox color as clear color

    **7. Create `packages/adapter-babylon/src/types.ts` and `src/index.ts`:**

    `types.ts`: Re-export `EngineAdapter`, `SerializedCameraState`, `IRDelta` from `@riff3d/canonical-ir`.

    `index.ts`: Export `BabylonAdapter`, type re-exports, `buildScene`, `destroySceneEntities`, `applyEnvironment`, `getSkyboxColor`, component mapper exports.

    **8. Consult FUTURE_ENGINE_CONSIDERATIONS.md (per pending todo):**

    When implementing the Babylon adapter, verify:
    - No web-only assumptions baked into adapter (e.g., `window`, `document` refs should be guarded)
    - Quaternion rotation used everywhere (no Euler shortcuts)
    - Left-handed coordinate awareness: negate Z for camera/light direction vectors derived from quaternions
    - Texture invertY awareness: document that textures should use `invertY: false` for glTF content (not needed in Phase 4 since we only have primitives)

    Run `pnpm install && pnpm turbo run typecheck test --filter=@riff3d/adapter-babylon`.
  </action>
  <verify>
    `pnpm turbo run typecheck --filter=@riff3d/adapter-babylon` passes.
    `pnpm turbo run test --filter=@riff3d/adapter-babylon` passes (all unit tests green).
    `pnpm turbo run typecheck test` (full monorepo) passes with no regressions.
    Babylon adapter core LoC is under 1500 (adapter.ts + scene-builder.ts + environment.ts + component-mappers/*).
  </verify>
  <done>
    @riff3d/adapter-babylon package exists with full scene rendering from Canonical IR. All 7 primitives, PBR materials, 3 light types, cameras, and environment settings translate correctly. Unit tests pass for all modules.
  </done>
</task>

</tasks>

<verification>
- `pnpm turbo run typecheck test` passes across entire monorepo
- EngineAdapter interface exists in @riff3d/canonical-ir (shared, not adapter-specific)
- PlayCanvas adapter still works with no regressions (re-exports maintain backward compatibility)
- Babylon adapter has unit tests for scene-builder, component-mappers, and environment
- Babylon adapter core LoC tracked (target: under 1500)
</verification>

<success_criteria>
- BabylonAdapter implements EngineAdapter and can build a scene from any valid CanonicalScene
- All 7 primitive types render, PBR materials apply correctly, 3 light types work, cameras work, environment applies
- Unit tests provide coverage for every component mapper and environment setting
- EngineAdapter + IRDelta types are shared in canonical-ir, used by both adapters
</success_criteria>

<output>
After completion, create `.planning/phases/04-dual-adapter-validation/04-01-SUMMARY.md`
</output>
