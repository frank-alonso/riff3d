---
phase: 04-dual-adapter-validation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/canonical-ir/src/delta.ts
  - packages/canonical-ir/src/index.ts
  - packages/adapter-playcanvas/src/adapter.ts
  - packages/adapter-playcanvas/src/delta.ts
  - packages/adapter-playcanvas/src/index.ts
  - packages/adapter-babylon/src/adapter.ts
  - packages/adapter-babylon/src/delta.ts
  - packages/adapter-babylon/src/index.ts
  - apps/editor/src/stores/slices/scene-slice.ts
  - packages/adapter-playcanvas/__tests__/delta.test.ts
  - packages/adapter-babylon/__tests__/delta.test.ts
autonomous: true
requirements:
  - ADPT-03

must_haves:
  truths:
    - "Editing a transform property in the inspector updates the adapter via delta (O(1)) without rebuilding the entire scene"
    - "Editing a component property (e.g., material color) updates via delta without full rebuild"
    - "Editing environment settings (ambient, fog, skybox) updates via delta without full rebuild"
    - "Structural PatchOps (CreateEntity, DeleteEntity, Reparent, AddComponent, RemoveComponent) still trigger full rebuild"
    - "Both adapters handle delta application identically (same PatchOp produces same visual result)"
    - "Undo and redo operations always trigger full scene rebuild (lastDelta is null after undo/redo)"
  artifacts:
    - path: "packages/canonical-ir/src/delta.ts"
      provides: "computeDelta function mapping PatchOp to IRDelta"
      exports: ["computeDelta"]
    - path: "packages/adapter-playcanvas/src/delta.ts"
      provides: "PlayCanvas delta application logic"
      exports: ["applyPlayCanvasDelta"]
    - path: "packages/adapter-babylon/src/delta.ts"
      provides: "Babylon delta application logic"
      exports: ["applyBabylonDelta"]
  key_links:
    - from: "apps/editor/src/stores/slices/scene-slice.ts"
      to: "@riff3d/canonical-ir"
      via: "computeDelta called in dispatchOp before full compile"
      pattern: "computeDelta"
    - from: "packages/adapter-playcanvas/src/adapter.ts"
      to: "packages/adapter-playcanvas/src/delta.ts"
      via: "applyDelta delegates to engine-specific delta handler"
      pattern: "applyPlayCanvasDelta"
    - from: "packages/adapter-babylon/src/adapter.ts"
      to: "packages/adapter-babylon/src/delta.ts"
      via: "applyDelta delegates to engine-specific delta handler"
      pattern: "applyBabylonDelta"
---

<objective>
Implement the incremental delta update system that replaces full scene rebuilds with O(1) property-level updates for both adapters.

Purpose: Every property edit in the inspector currently triggers a full scene rebuild (compile entire ECSON -> destroy all engine entities -> recreate all). This is the #1 performance bottleneck during editing. The delta system maps PatchOp types to minimal engine operations, making property edits feel instant.

Output: `computeDelta()` function in canonical-ir, `applyDelta()` implementations in both adapters, and scene-slice integration that routes property changes through deltas instead of full rebuilds.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dual-adapter-validation/04-RESEARCH.md
@.planning/phases/04-dual-adapter-validation/04-01-SUMMARY.md

# Current full-rebuild flow:
@apps/editor/src/stores/slices/scene-slice.ts
@packages/adapter-playcanvas/src/adapter.ts
@packages/adapter-playcanvas/src/scene-builder.ts

# IR types including IRDelta (created in 04-01):
@packages/canonical-ir/src/types/ir-delta.ts
@packages/canonical-ir/src/types/engine-adapter.ts
@packages/canonical-ir/src/index.ts

# PlayCanvas component mappers (for delta property mapping):
@packages/adapter-playcanvas/src/component-mappers/mesh-renderer.ts
@packages/adapter-playcanvas/src/component-mappers/material.ts
@packages/adapter-playcanvas/src/component-mappers/light.ts
@packages/adapter-playcanvas/src/component-mappers/camera.ts

# Babylon adapter (from 04-01):
@packages/adapter-babylon/src/adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: computeDelta mapper and adapter delta implementations</name>
  <files>
    packages/canonical-ir/src/delta.ts
    packages/canonical-ir/src/index.ts
    packages/adapter-playcanvas/src/delta.ts
    packages/adapter-playcanvas/src/adapter.ts
    packages/adapter-playcanvas/src/index.ts
    packages/adapter-babylon/src/delta.ts
    packages/adapter-babylon/src/adapter.ts
    packages/adapter-babylon/src/index.ts
  </files>
  <action>
    **1. Create `packages/canonical-ir/src/delta.ts` -- PatchOp to IRDelta mapper:**

    This function examines a PatchOp and returns an `IRDelta` if the change can be applied incrementally, or `{ type: "full-rebuild" }` if a full rebuild is needed.

    ```typescript
    export function computeDelta(op: PatchOp): IRDelta
    ```

    Import `PatchOp` type from `@riff3d/patchops` -- add this as a devDependency to canonical-ir package.json (type-only import, no runtime dependency). Actually, better: accept a simplified shape `{ type: string; payload: unknown }` to avoid adding the patchops dependency to canonical-ir. The function only reads `.type` and `.payload`.

    Mapping rules:
    - `SetProperty` with `path = "transform.position"` -> `{ type: "node-transform", nodeId, transform: { position: value } }`
    - `SetProperty` with `path = "transform.rotation"` -> `{ type: "node-transform", nodeId, transform: { rotation: value } }`
    - `SetProperty` with `path = "transform.scale"` -> `{ type: "node-transform", nodeId, transform: { scale: value } }`
    - `SetProperty` with `path = "visible"` -> `{ type: "node-visibility", nodeId, visible: value }`
    - `SetProperty` with `path = "environment.*"` -> `{ type: "environment", path: <strip "environment." prefix>, value }`
    - `SetComponentProperty` -> `{ type: "component-property", nodeId: entityId, componentIndex, property, value }`
    - `CreateEntity`, `DeleteEntity`, `Reparent`, `AddComponent`, `RemoveComponent` -> `{ type: "full-rebuild" }`
    - `BatchOp` -> `{ type: "full-rebuild" }` (batch operations are structural by convention; individual property changes don't batch)

    Export from `packages/canonical-ir/src/index.ts`.

    **2. Create `packages/adapter-playcanvas/src/delta.ts` -- PlayCanvas delta application:**

    ```typescript
    export function applyPlayCanvasDelta(
      entityMap: Map<string, pc.Entity>,
      app: pc.Application,
      editorCamera: pc.Entity | null,
      delta: IRDelta,
    ): void
    ```

    Handle each delta type:
    - `node-transform`: Look up entity by nodeId in entityMap. Call `setLocalPosition/setLocalRotation/setLocalScale` for each present field. This is O(1).
    - `node-visibility`: `entity.enabled = delta.visible`
    - `component-property`: Look up entity, find the PC component by index/type, set the property. For materials: find render component -> material -> set property. For lights: find light component -> set property. For cameras: find camera component -> set property. This requires mapping IR property names to PlayCanvas property names (e.g., roughness -> gloss inversion).
    - `environment`: Apply the specific environment property change to `app.scene` (ambient, fog, skybox). Reuse helpers from `environment.ts`.
    - `full-rebuild`: Return without doing anything (caller falls back to full rebuild).

    **3. Create `packages/adapter-babylon/src/delta.ts` -- Babylon delta application:**

    ```typescript
    export function applyBabylonDelta(
      entityMap: Map<string, TransformNode>,
      scene: Scene,
      delta: IRDelta,
    ): void
    ```

    Handle each delta type:
    - `node-transform`: `node.position = new Vector3(...)`, `node.rotationQuaternion = new Quaternion(...)`, `node.scaling = new Vector3(...)`
    - `node-visibility`: `node.setEnabled(delta.visible)`
    - `component-property`: Find the Babylon object by type. For materials: `node.material?.prop = value`. For lights: direct property access. For cameras: direct property access.
      CRITICAL: roughness is direct pass-through (NO inversion). FOV/angles need degree-to-radian conversion.
    - `environment`: Apply to scene properties directly (ambientColor, fogMode, clearColor).
    - `full-rebuild`: Return without doing anything.

    **4. Wire `applyDelta` into both adapter classes:**

    In `PlayCanvasAdapter.applyDelta(delta)`:
    - If `delta.type === "full-rebuild"`: call `this.rebuildScene(this.currentScene!)` and return
    - Otherwise: call `applyPlayCanvasDelta(this.entityMap, this.app!, this.editorCamera, delta)`

    In `BabylonAdapter.applyDelta(delta)`:
    - If `delta.type === "full-rebuild"`: call `this.rebuildScene(this.currentScene!)` and return
    - Otherwise: call `applyBabylonDelta(this.entityMap, this.scene!, delta)`

    Update both adapter index.ts files to export delta functions.

    **IMPORTANT: Do NOT modify scene-slice.ts in this task.** Scene-slice integration is Task 2. This task only creates the delta infrastructure and adapter implementations.
  </action>
  <verify>
    `pnpm turbo run typecheck --filter=@riff3d/canonical-ir --filter=@riff3d/adapter-playcanvas --filter=@riff3d/adapter-babylon` passes.
    All existing tests still pass: `pnpm turbo run test --filter=@riff3d/adapter-playcanvas --filter=@riff3d/adapter-babylon`
  </verify>
  <done>
    computeDelta() maps PatchOp types to IRDelta. Both adapters have applyDelta() implementations that handle transform, visibility, component-property, and environment deltas. Full-rebuild fallback works for structural changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scene-slice integration and delta tests</name>
  <files>
    apps/editor/src/stores/slices/scene-slice.ts
    packages/adapter-playcanvas/__tests__/delta.test.ts
    packages/adapter-babylon/__tests__/delta.test.ts
  </files>
  <action>
    **1. Modify `apps/editor/src/stores/slices/scene-slice.ts` -- delta-aware dispatch:**

    The current flow is:
    ```
    dispatchOp(op) -> applyOp(doc, op) -> compile(doc) -> set({ canonicalScene })
    ```
    The viewport subscribes to `canonicalScene` changes and calls `adapter.rebuildScene()`.

    The new flow adds delta computation:
    ```
    dispatchOp(op) -> applyOp(doc, op) -> computeDelta(op) -> compile(doc) -> set({ canonicalScene, lastDelta })
    ```

    Add to SceneSlice interface:
    ```typescript
    /** The last computed delta from the most recent PatchOp. Null for full rebuilds. */
    lastDelta: IRDelta | null;
    ```

    In `dispatchOp`:
    - After `applyOp(ecsonDoc, op)`, call `computeDelta(op)` to get the delta
    - Still call `compile(ecsonDoc)` to keep canonicalScene in sync (needed for correctness -- full IR is the source of truth for recompilation)
    - Set `lastDelta` alongside `canonicalScene`

    In `loadProject`, `undo`, `redo`:
    - Set `lastDelta: null` (these are always full rebuilds)

    **NOTE:** The viewport-canvas.tsx subscriber that routes deltas to the adapter is handled by 04-03, which does the full viewport-canvas.tsx rewrite for engine switching. 04-03 will incorporate the delta-aware subscriber logic (checking `lastDelta` before deciding between `applyDelta()` and `rebuildScene()`). This plan only adds `lastDelta` to the scene-slice state; the wiring to the adapter happens in 04-03.

    **2. Write delta tests:**

    `packages/adapter-playcanvas/__tests__/delta.test.ts`:
    - Test: transform delta sets position/rotation/scale on entity
    - Test: visibility delta sets entity.enabled
    - Test: component-property delta for material color changes material property
    - Test: environment delta changes scene fog/ambient
    - Test: full-rebuild delta returns without modifying entities (caller handles)
    - Test: delta for unknown nodeId is a no-op (defensive)

    `packages/adapter-babylon/__tests__/delta.test.ts`:
    - Same test cases as PlayCanvas but verifying Babylon-specific property mapping
    - Test: roughness delta is direct (no inversion)
    - Test: FOV delta converts degrees to radians
    - Test: transform delta uses rotationQuaternion (not rotation Euler)

    Use the existing mock infrastructure from each adapter's test helpers.

    **Additionally, add a scene-slice undo/redo invariant test** (in adapter-playcanvas or a shared test file):
    - Test: After `dispatchOp` sets a transform, `lastDelta` is non-null (an IRDelta)
    - Test: After `undo()`, `lastDelta` is `null` (full rebuild triggered)
    - Test: After `redo()`, `lastDelta` is `null` (full rebuild triggered)
    - Test: After `loadProject()`, `lastDelta` is `null` (full rebuild triggered)
    This verifies the critical invariant that undo/redo always produces a full rebuild, preventing stale delta application.
  </action>
  <verify>
    `pnpm turbo run typecheck test` passes across entire monorepo.
    `pnpm turbo run test --filter=@riff3d/adapter-playcanvas --filter=@riff3d/adapter-babylon` -- new delta tests pass.
    Manual verification (if possible): edit a transform in inspector and confirm no flicker (delta applied, not full rebuild).
  </verify>
  <done>
    Scene-slice computes deltas from PatchOps and stores `lastDelta` alongside `canonicalScene`. Both adapters have tested delta application logic. Structural changes still trigger full rebuild. Viewport subscriber wiring deferred to 04-03 (which rewrites viewport-canvas.tsx for engine switching and incorporates delta routing there).
  </done>
</task>

</tasks>

<verification>
- `pnpm turbo run typecheck test` passes (no regressions)
- SetProperty ops for transform/visibility/component/environment produce IRDelta (not full rebuild)
- CreateEntity/DeleteEntity/Reparent/AddComponent/RemoveComponent produce full-rebuild delta
- Both adapters apply deltas correctly (verified by unit tests)
- Scene-slice stores lastDelta alongside canonicalScene
</verification>

<success_criteria>
- Property edits flow through delta path (O(1) per property) instead of full rebuild (O(n))
- Structural edits still trigger full rebuild (correctness maintained)
- Both adapters handle all delta types identically (same input -> same visual result)
- No regressions in existing editor functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-dual-adapter-validation/04-02-SUMMARY.md`
</output>
