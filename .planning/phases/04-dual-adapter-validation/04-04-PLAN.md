---
phase: 04-dual-adapter-validation
plan: 04
type: execute
wave: 4
depends_on: ["04-02", "04-03"]
files_modified:
  - packages/conformance/src/adapter-conformance.ts
  - packages/conformance/src/index.ts
  - packages/conformance/__tests__/playcanvas-conformance.test.ts
  - packages/conformance/__tests__/babylon-conformance.test.ts
  - packages/conformance/__tests__/helpers/adapter-test-helpers.ts
  - apps/editor/e2e/dual-adapter.visual.ts
  - apps/editor/e2e/fixtures/tolerance-bands.ts
  - packages/adapter-playcanvas/__tests__/property-tests.test.ts
  - packages/adapter-playcanvas/package.json
  - packages/adapter-babylon/__tests__/property-tests.test.ts
  - packages/adapter-babylon/package.json
  - scripts/check-adapter-loc.sh
autonomous: true
requirements:
  - ADPT-04
  - TEST-04

must_haves:
  truths:
    - "All golden fixtures pass unit-level conformance on both adapters (scene builds without errors, entity counts match)"
    - "Visual regression tests run both engines on each fixture with per-fixture tolerance bands"
    - "Spot light inner cone tolerance is explicitly documented as an acceptable difference"
    - "Multi-seed property test suite (3 seeds x 50 iterations) runs in CI"
    - "Babylon adapter core LoC is under 1500 (tracked by CI script)"
    - "Visual regression is promoted to required CI (not non-blocking beta)"
  artifacts:
    - path: "packages/conformance/src/adapter-conformance.ts"
      provides: "Cross-adapter conformance test harness"
      exports: ["runAdapterConformance"]
    - path: "apps/editor/e2e/dual-adapter.visual.ts"
      provides: "Visual regression E2E tests for both engines"
    - path: "apps/editor/e2e/fixtures/tolerance-bands.ts"
      provides: "Per-fixture tolerance band definitions"
      exports: ["TOLERANCE_BANDS"]
    - path: "scripts/check-adapter-loc.sh"
      provides: "CI script for adapter LoC budget enforcement"
  key_links:
    - from: "packages/conformance/src/adapter-conformance.ts"
      to: "@riff3d/canonical-ir"
      via: "uses EngineAdapter interface to test both adapters generically"
      pattern: "EngineAdapter"
    - from: "packages/conformance/__tests__/playcanvas-conformance.test.ts"
      to: "@riff3d/adapter-playcanvas"
      via: "instantiates PlayCanvasAdapter for conformance"
      pattern: "PlayCanvasAdapter"
    - from: "packages/conformance/__tests__/babylon-conformance.test.ts"
      to: "@riff3d/adapter-babylon"
      via: "instantiates BabylonAdapter for conformance"
      pattern: "BabylonAdapter"
---

<objective>
Build the conformance test suite that validates both adapters produce consistent results for all golden fixtures, with visual regression at defined tolerance bands, and address carry-forward items from Phase 3.

Purpose: This is the definitive proof that the Canonical IR is engine-agnostic. If both adapters pass conformance on the same golden fixtures, the IR contract is validated. Visual regression with tolerance bands catches rendering differences while allowing acceptable engine-specific variations.

Output: Cross-adapter conformance harness, visual E2E tests for both engines, per-fixture tolerance bands, multi-seed property tests, and CI-enforced LoC budget.
</objective>

<execution_context>
@/home/frank/.claude/get-shit-done/workflows/execute-plan.md
@/home/frank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dual-adapter-validation/04-RESEARCH.md
@.planning/phases/04-dual-adapter-validation/04-01-SUMMARY.md
@.planning/phases/04-dual-adapter-validation/04-02-SUMMARY.md
@.planning/phases/04-dual-adapter-validation/04-03-SUMMARY.md

# Existing conformance harness:
@packages/conformance/src/harness.ts
@packages/conformance/src/round-trip.ts
@packages/conformance/src/benchmarks.ts
@packages/conformance/src/budgets.ts
@packages/conformance/src/index.ts

# Golden fixtures:
@packages/fixtures/src/index.ts

# Existing visual tests:
@apps/editor/e2e/fixture-render.visual.ts

# Adapter exports (from 04-01):
@packages/adapter-playcanvas/src/index.ts
@packages/adapter-babylon/src/index.ts
@packages/canonical-ir/src/types/engine-adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cross-adapter conformance harness and unit tests</name>
  <files>
    packages/conformance/src/adapter-conformance.ts
    packages/conformance/src/index.ts
    packages/conformance/__tests__/helpers/adapter-test-helpers.ts
    packages/conformance/__tests__/playcanvas-conformance.test.ts
    packages/conformance/__tests__/babylon-conformance.test.ts
    packages/conformance/package.json
    packages/adapter-playcanvas/__tests__/property-tests.test.ts
    packages/adapter-playcanvas/package.json
    packages/adapter-babylon/__tests__/property-tests.test.ts
    packages/adapter-babylon/package.json
    scripts/check-adapter-loc.sh
  </files>
  <action>
    **1. Create `packages/conformance/src/adapter-conformance.ts` -- generic conformance harness:**

    This module tests adapter behavior generically against the `EngineAdapter` interface. It does NOT import any specific adapter -- callers provide the adapter instance.

    ```typescript
    import type { EngineAdapter } from "@riff3d/canonical-ir";
    import type { CanonicalScene } from "@riff3d/canonical-ir";

    export interface ConformanceResult {
      fixture: string;
      passed: boolean;
      entityCount: number;
      expectedEntityCount: number;
      errors: string[];
    }

    /**
     * Run conformance checks for a single fixture against an adapter.
     * Tests:
     * 1. loadScene does not throw
     * 2. Entity map has correct number of entries (matches IR node count)
     * 3. rebuildScene does not throw
     * 4. Entity map is consistent after rebuild
     * 5. applyDelta with a transform delta does not throw
     * 6. dispose does not throw
     */
    export function runAdapterConformance(
      adapter: EngineAdapter,
      fixtureName: string,
      scene: CanonicalScene,
    ): ConformanceResult
    ```

    Add `@riff3d/adapter-playcanvas` and `@riff3d/adapter-babylon` as devDependencies of the conformance package.

    Export from `packages/conformance/src/index.ts`.

    **2. Create test helpers:**

    `packages/conformance/__tests__/helpers/adapter-test-helpers.ts`:
    - Helper to load all golden fixtures via `@riff3d/fixtures`
    - Helper to compile each fixture ECSON to CanonicalScene via `compile()` from `@riff3d/canonical-ir`
    - Helper to create mock adapters with globalThis stubs (re-use patterns from adapter test helpers)

    **3. Create PlayCanvas conformance tests:**

    `packages/conformance/__tests__/playcanvas-conformance.test.ts`:
    - For each golden fixture:
      - Compile to CanonicalScene
      - Create PlayCanvasAdapter (with mocked canvas via globalThis stubs)
      - Run `runAdapterConformance(adapter, name, scene)`
      - Assert `result.passed === true`
      - Assert `result.entityCount === result.expectedEntityCount`
    - Test: rebuildScene produces same entity count as initial loadScene
    - Test: applyDelta with transform does not throw

    **4. Create Babylon conformance tests:**

    `packages/conformance/__tests__/babylon-conformance.test.ts`:
    - Same structure as PlayCanvas conformance tests
    - For each golden fixture:
      - Compile to CanonicalScene
      - Create BabylonAdapter (with mocked canvas via globalThis stubs)
      - Run `runAdapterConformance(adapter, name, scene)`
      - Assert all passing

    **5. Add fast-check devDependencies to both adapter packages:**

    Both adapter packages need fast-check for property tests. Update their package.json files:

    `packages/adapter-playcanvas/package.json` -- add to devDependencies:
    ```json
    "@fast-check/vitest": "catalog:",
    "fast-check": "catalog:"
    ```

    `packages/adapter-babylon/package.json` -- add to devDependencies:
    ```json
    "@fast-check/vitest": "catalog:",
    "fast-check": "catalog:"
    ```

    If `fast-check` and `@fast-check/vitest` are not yet in the pnpm-workspace.yaml catalog, add them there first (check existing catalog entries). Then run `pnpm install` to resolve.

    **6. Multi-seed property tests (CF-P3-03):**

    `packages/adapter-playcanvas/__tests__/property-tests.test.ts`:
    - Use fast-check with 3 different seeds (42, 123, 456) x 50 iterations each
    - Property: For any valid CanonicalScene, loadScene + getEntityMap produces entityMap with size === scene.nodes.length
    - Property: For any valid transform delta, applyDelta does not throw
    - Property: rebuildScene is idempotent (entity count unchanged)

    `packages/adapter-babylon/__tests__/property-tests.test.ts`:
    - Same properties as PlayCanvas

    **7. Create `scripts/check-adapter-loc.sh`:**

    Update or create the adapter LoC budget check script to include the Babylon adapter:
    ```bash
    #!/bin/bash
    # Check adapter core LoC budget (max 1500 LoC per adapter core)
    # Core = adapter.ts + scene-builder.ts + environment.ts + component-mappers/*
    # Editor tools tracked separately

    BUDGET=1500

    for adapter in adapter-playcanvas adapter-babylon; do
      CORE_FILES=$(find "packages/$adapter/src" -name "*.ts" \
        ! -path "*/editor-tools/*" \
        ! -path "*/__tests__/*" \
        ! -name "index.ts" \
        ! -name "types.ts")
      LOC=$(cat $CORE_FILES | wc -l)
      echo "$adapter core: $LOC / $BUDGET LoC"
      if [ "$LOC" -gt "$BUDGET" ]; then
        echo "FAIL: $adapter exceeds LoC budget"
        exit 1
      fi
    done
    echo "All adapters within LoC budget"
    ```

    Ensure this script runs in CI (check if already wired into GitHub Actions or turbo pipeline).

    **8. Update conformance package.json:**

    Add dependencies:
    - `@riff3d/adapter-playcanvas` (workspace:*, devDependency)
    - `@riff3d/adapter-babylon` (workspace:*, devDependency)
    - `@riff3d/canonical-ir` (workspace:*, if not already present)
    - `@riff3d/fixtures` (workspace:*, if not already present)
  </action>
  <verify>
    `pnpm turbo run test --filter=@riff3d/conformance` -- all conformance tests pass for both adapters.
    `pnpm turbo run test --filter=@riff3d/adapter-playcanvas --filter=@riff3d/adapter-babylon` -- property tests pass.
    `bash scripts/check-adapter-loc.sh` -- both adapters within budget.
  </verify>
  <done>
    Cross-adapter conformance harness validates both adapters against all golden fixtures. Multi-seed property tests provide invariant coverage. LoC budget enforced for both adapters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Visual regression with per-fixture tolerance bands</name>
  <files>
    apps/editor/e2e/dual-adapter.visual.ts
    apps/editor/e2e/fixtures/tolerance-bands.ts
  </files>
  <action>
    **1. Create `apps/editor/e2e/fixtures/tolerance-bands.ts`:**

    Define per-fixture tolerance bands for visual comparison:

    ```typescript
    export interface ToleranceBand {
      /** Maximum percentage of pixels that can differ */
      maxDiffPixels: number;
      /** Maximum color distance per pixel (0-1 scale) */
      maxColorDelta: number;
      /** Acceptable regions to mask (e.g., shadow edges) */
      maskRegions?: Array<{ x: number; y: number; width: number; height: number }>;
    }

    export const TOLERANCE_BANDS: Record<string, ToleranceBand> = {
      // Simple scenes with primitives and basic materials
      "minimal-scene": { maxDiffPixels: 0.02, maxColorDelta: 0.05 },
      "basic-lighting": { maxDiffPixels: 0.03, maxColorDelta: 0.08 },
      // Material-heavy scenes (PBR differences between engines)
      "pbr-materials": { maxDiffPixels: 0.05, maxColorDelta: 0.10 },
      // Scenes with spot lights (inner cone approximation tolerance)
      "spot-lighting": { maxDiffPixels: 0.08, maxColorDelta: 0.15 },
      // Complex scenes with many entities
      "adversarial": { maxDiffPixels: 0.05, maxColorDelta: 0.10 },
      // Default for unlisted fixtures
      "default": { maxDiffPixels: 0.05, maxColorDelta: 0.10 },
    };
    ```

    Adjust fixture names to match actual golden fixture names from `@riff3d/fixtures`. Read the fixtures package to get exact names.

    Document: Spot light inner cone angle is a known acceptable difference (Babylon uses exponent approximation, not exact inner cone). This is captured in the higher tolerance for spot-lighting fixtures.

    **2. Create `apps/editor/e2e/dual-adapter.visual.ts`:**

    Playwright visual regression tests that render each golden fixture on both engines and compare:

    ```typescript
    import { test, expect } from "@playwright/test";
    import { TOLERANCE_BANDS } from "./fixtures/tolerance-bands";

    const FIXTURES = ["minimal-scene", "basic-lighting", "pbr-materials", /* ... */];
    const ENGINES = ["playcanvas", "babylon"] as const;

    for (const fixture of FIXTURES) {
      for (const engine of ENGINES) {
        test(`${fixture} renders correctly on ${engine}`, async ({ page }) => {
          // Navigate to editor with fixture loaded (default engine is PlayCanvas)
          await page.goto(`/editor/test-project?fixture=${fixture}`);

          // Wait for initial scene ready signal
          await page.waitForFunction(() => {
            return (window as any).__sceneReady === true;
          }, { timeout: 30000 });

          // If target engine is not the default, switch via store
          if (engine !== "playcanvas") {
            // Reset scene ready flag before switching
            await page.evaluate(() => {
              (window as any).__sceneReady = false;
              (window as any).__sceneAlreadyReady = false;
            });

            // Call switchEngine on the editor store directly
            await page.evaluate((targetEngine) => {
              const store = (window as any).__editorStore;
              if (!store) throw new Error("Editor store not found on window");
              store.getState().switchEngine(targetEngine);
            }, engine);

            // Wait for the new engine's scene ready signal
            await page.waitForFunction(() => {
              return (window as any).__sceneReady === true;
            }, { timeout: 30000 });
          }

          // Take screenshot
          const tolerance = TOLERANCE_BANDS[fixture] ?? TOLERANCE_BANDS["default"];
          await expect(page.locator("canvas")).toHaveScreenshot(
            `${fixture}-${engine}.png`,
            {
              maxDiffPixels: Math.round(tolerance.maxDiffPixels * 1920 * 1080), // approximate viewport
              threshold: tolerance.maxColorDelta,
            },
          );
        });
      }

      // Cross-engine comparison (same fixture, different engines)
      test(`${fixture} cross-engine visual consistency`, async ({ page }) => {
        // This test compares PlayCanvas and Babylon screenshots of the same fixture.
        // It uses broader tolerance to account for engine-level rendering differences.
        // The screenshots are generated by the per-engine tests above.
        // Playwright's built-in comparison handles this via the golden file mechanism.
        // NOTE: Cross-engine comparison is advisory (not blocking) because
        // engines will always have some visual differences.
      });
    }
    ```

    **IMPORTANT -- Engine switching in E2E:** There is no `?engine=` query param handler in the editor app. Instead, use `page.evaluate()` to call `switchEngine()` on the editor store directly after the scene loads with the default PlayCanvas engine. This matches the existing store-based approach. The editor store must be exposed on `window.__editorStore` for E2E access (check if this is already done in the golden-path E2E test helpers; if not, add `(window as any).__editorStore = editorStore` in the store initialization code for development/test builds only).

    Handling the `__sceneReady` signal: The adapters already dispatch this event (PlayCanvas in loadScene, Babylon should match from 04-01). Set `(window as any).__sceneReady = true` on the `__sceneReady` custom event.

    For the test project route: the existing E2E test infrastructure should have a way to load fixtures. Check the existing golden-path E2E test (`apps/editor/e2e/golden-path.e2e.ts`) for the pattern and follow it.

    **3. Promote visual regression to required CI (CF-P3-02):**

    Update the Playwright config or CI workflow to mark visual tests as required (not `test.skip` or `.only`). The per-fixture tolerance bands replace the generic beta thresholds from Phase 3.

    If the existing visual tests use `test.skip` conditionally, remove those conditions. If they use a separate non-blocking CI job, merge them into the main test job (or keep separate but mark as required).

    Document that visual regression is now required with per-fixture tolerance bands, superseding the Phase 3 non-blocking beta status.

    **IMPORTANT:** The cross-engine comparison test is advisory -- it documents expected differences but does not block CI. Per-engine rendering correctness (each engine matches its own baseline) is what's required.
  </action>
  <verify>
    `pnpm exec playwright test apps/editor/e2e/dual-adapter.visual.ts` -- visual tests run (may need baseline generation on first run).
    Per-fixture tolerance bands defined for all golden fixtures.
    Spot light tolerance explicitly wider than other fixtures (documented acceptable difference).
    Visual regression marked as required in CI config (not non-blocking beta).
  </verify>
  <done>
    Visual regression tests run both engines on all golden fixtures with per-fixture tolerance bands. Spot light inner cone difference documented. Visual regression promoted from non-blocking beta to required CI. Cross-engine comparison is advisory.
  </done>
</task>

</tasks>

<verification>
- `pnpm turbo run test --filter=@riff3d/conformance` -- all conformance tests pass
- `pnpm turbo run test --filter=@riff3d/adapter-playcanvas --filter=@riff3d/adapter-babylon` -- all tests pass including property tests
- `bash scripts/check-adapter-loc.sh` -- both adapters within 1500 LoC core budget
- Visual regression tests have per-fixture tolerance bands
- Multi-seed property tests (3 seeds x 50 iterations) are in test suite
</verification>

<success_criteria>
- All golden fixtures pass unit-level conformance on both adapters
- Visual regression runs both engines with tolerance bands (required CI, not beta)
- Spot light inner cone documented as acceptable tolerance
- Property tests provide invariant coverage across both adapters
- LoC budget enforced for both adapter cores
</success_criteria>

<output>
After completion, create `.planning/phases/04-dual-adapter-validation/04-04-SUMMARY.md`
</output>
